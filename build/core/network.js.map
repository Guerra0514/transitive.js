{"version":3,"sources":["network.js"],"names":["debug","require","Network","transitive","data","routes","stops","patterns","places","journeys","paths","baseVertexPoints","graph","load","adjacentStops","turnPoints","streetEdges","latLons","decode","streetEdgeData","geometry","points","coords","push","forward","latLon","edge_id","worldCoords","length","routeData","route_id","stopData","stop_id","pattern","patternData","pattern_id","route","addPattern","render","createPath","place","placeData","place_id","addVertexPoint","journey","journeyData","journey_id","path","p","s","segments","processSegment","stopId","turnLookup","addTurn","turn1","turn2","getId","indexOf","streetEdge","fromTurnPoint","toTurnPoint","turnPointId","count","createGraph","loaded","emit","clearGraphData","applyZoomFactors","display","activeZoomFactors","pointClusterMap","clearMultiPoints","stop","setFocused","vertexPoints","mergeVertexThreshold","getVertexPoints","populateGraphEdges","pruneVertices","createInternalVertexPoints","isSnapping","snapToGrid","gridCellSize","sortVertices","annotateTransitPoints","createRenderedSegments","labeler","updateLabelList","updateGeometry","internalVertexPoints","i","edgeGroups","edgeGroup","wlen","getWorldLength","splitPoints","hasTransit","vertexFactor","internalVertexFactor","newVertexCount","Math","floor","pq","getInternalVertexPQ","size","el","deq","point","e","edges","edge","splitEdgeAtInternalPoints","forEach","pointGeom","geomCoords","slice","vertices","vertex","clearRenderData","pointArray","renderedEdges","rEdge","clearOffsets","calculateGeometry","angleConstraint","apply2DOffsets","factors","useGeographicRendering","segment","previousStop","used","getType","addStopAdjacency","startPoint","isSegmentEndPoint","endPoint","stopIdA","stopIdB","lastVertex","internalPoints","streetEdgeIndex","representativePattern","type","patternGroup","interStopGeometry","index","concat","fromIndex","getFromIndex","geom","multipoint","graphVertex","fromVertex","toVertex","getEquivalentEdge","addEdge","addPathSegment","toString","transitSegments","pathSegment","isBoardPoint","isTransferPoint","isAlightPoint","incidentEdges","oppVertex","oppositeVertex","adjacentPlace","reLookup","renderedSegments","patternId","busPatterns","getPatterns","route_type","createRenderedSegment","sort","a","b","rSegment","createRenderedEdge","graphEdge","addRenderedEdge","mode","addRenderedSegment","gEdge","split","key","id","prototype"],"mappings":"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","file":"network.js","sourcesContent":["const debug = require('debug')('transitive:network')\n\nimport { forEach } from 'lodash'\nimport Emitter from 'component-emitter'\n\nimport Route from './route'\nimport RoutePattern from './pattern'\nimport Journey from './journey'\nimport Stop from '../point/stop'\nimport Place from '../point/place'\nimport PointClusterMap from '../point/pointclustermap'\nimport RenderedEdge from '../renderer/renderededge'\nimport RenderedSegment from '../renderer/renderedsegment'\nimport Graph from '../graph/graph'\nimport Polyline from '../util/polyline.js'\nimport { sm } from '../util'\n\n/**\n * Network\n */\nexport default class Network {\n  constructor (transitive, data) {\n    this.transitive = transitive\n\n    this.routes = {}\n    this.stops = {}\n    this.patterns = {}\n    this.places = {}\n    this.journeys = {}\n    this.paths = []\n    this.baseVertexPoints = []\n    this.graph = new Graph(this, [])\n\n    if (data) this.load(data)\n  }\n\n  /**\n   * Load\n   *\n   * @param {Object} data\n   */\n\n  load (data) {\n    debug('loading', data)\n\n    // check data\n    if (!data) data = {}\n\n    // Store data\n    this.data = data\n\n    // A list of points (stops & places) that will always become vertices in the network\n    // graph (regardless of zoom scale). This includes all points that serve as a segment\n    // endpoint and/or a convergence/divergence point between segments\n    this.baseVertexPoints = []\n\n    // object maps stop ids to arrays of unique stop_ids reachable from that stop\n    this.adjacentStops = {}\n\n    // maps lat_lon key to unique TurnPoint object\n    this.turnPoints = {}\n\n    // Copy/decode the streetEdge objects\n    this.streetEdges = {}\n    forEach(data.streetEdges, streetEdgeData => {\n      const latLons = Polyline.decode(streetEdgeData.geometry.points)\n      const coords = []\n      forEach(latLons, latLon => {\n        coords.push(sm.forward([latLon[1], latLon[0]]))\n      })\n      this.streetEdges[streetEdgeData.edge_id] = {\n        latLons: latLons,\n        worldCoords: coords,\n        length: streetEdgeData.geometry.length\n      }\n    })\n\n    // Generate the route objects\n    this.routes = {}\n    forEach(data.routes, routeData => {\n      this.routes[routeData.route_id] = new Route(routeData)\n    })\n\n    // Generate the stop objects\n    this.stops = {}\n    forEach(data.stops, stopData => {\n      this.stops[stopData.stop_id] = new Stop(stopData)\n    })\n\n    // Generate the pattern objects\n    this.patterns = {}\n    forEach(data.patterns, patternData => {\n      const pattern = new RoutePattern(patternData, this)\n      this.patterns[patternData.pattern_id] = pattern\n      const route = this.routes[patternData.route_id]\n      if (route) {\n        route.addPattern(pattern)\n        pattern.route = route\n      } else {\n        debug('Error: pattern ' + patternData.pattern_id +\n          ' refers to route that was not found: ' + patternData.route_id)\n      }\n      if (pattern.render) this.paths.push(pattern.createPath())\n    })\n\n    // Generate the place objects\n    this.places = {}\n    forEach(data.places, placeData => {\n      const place = this.places[placeData.place_id] = new Place(placeData, this)\n      this.addVertexPoint(place)\n    })\n\n    // Generate the internal Journey objects\n    this.journeys = {}\n    forEach(data.journeys, journeyData => {\n      const journey = new Journey(journeyData, this)\n      this.journeys[journeyData.journey_id] = journey\n      this.paths.push(journey.path)\n    })\n\n    // process the path segments\n    for (var p = 0; p < this.paths.length; p++) {\n      var path = this.paths[p]\n      for (var s = 0; s < path.segments.length; s++) {\n        this.processSegment(path.segments[s])\n      }\n    }\n\n    // when rendering pattern paths only, determine convergence/divergence vertex\n    // stops by looking for stops w/ >2 adjacent stops\n    if (!data.journeys || data.journeys.length === 0) {\n      for (var stopId in this.adjacentStops) {\n        if (this.adjacentStops[stopId].length > 2) {\n          this.addVertexPoint(this.stops[stopId])\n        }\n      }\n    }\n\n    // determine which TurnPoints should be base vertices\n    var turnLookup = {}\n    var addTurn = function (turn1, turn2) {\n      if (!(turn1.getId() in turnLookup)) turnLookup[turn1.getId()] = []\n      if (turnLookup[turn1.getId()].indexOf(turn2) === -1) turnLookup[turn1.getId()].push(turn2)\n    }\n    forEach(Object.values(this.streetEdges), streetEdge => {\n      if (streetEdge.fromTurnPoint && streetEdge.toTurnPoint) {\n        addTurn(streetEdge.toTurnPoint, streetEdge.fromTurnPoint)\n        addTurn(streetEdge.fromTurnPoint, streetEdge.toTurnPoint)\n      }\n    })\n    for (const turnPointId in turnLookup) {\n      const count = turnLookup[turnPointId].length\n      if (count > 2) this.addVertexPoint(this.turnPoints[turnPointId])\n    }\n\n    this.createGraph()\n\n    this.loaded = true\n    this.emit('load', this)\n    return this\n  }\n\n  /** Graph Creation/Processing Methods **/\n\n  clearGraphData () {\n    forEach(this.paths, (path) => {\n      path.clearGraphData()\n    })\n  }\n\n  createGraph () {\n    this.applyZoomFactors(this.transitive.display.activeZoomFactors)\n\n    // clear previous graph-specific data\n    if (this.pointClusterMap) this.pointClusterMap.clearMultiPoints()\n    forEach(Object.values(this.stops), stop => {\n      stop.setFocused(true)\n    })\n\n    // create the list of vertex points\n    var vertexPoints\n    if (this.mergeVertexThreshold && this.mergeVertexThreshold > 0) {\n      this.pointClusterMap = new PointClusterMap(this, this.mergeVertexThreshold)\n      vertexPoints = this.pointClusterMap.getVertexPoints(this.baseVertexPoints)\n    } else vertexPoints = this.baseVertexPoints\n\n    // core graph creation steps\n    this.graph = new Graph(this, vertexPoints)\n    this.populateGraphEdges()\n    this.graph.pruneVertices()\n    this.createInternalVertexPoints()\n    if (this.isSnapping()) this.graph.snapToGrid(this.gridCellSize)\n    this.graph.sortVertices()\n\n    // other post-processing actions\n    this.annotateTransitPoints()\n    // this.initPlaceAdjacency();\n    this.createRenderedSegments()\n    this.transitive.labeler.updateLabelList(this.graph)\n    this.updateGeometry(true)\n  }\n\n  isSnapping () {\n    return this.gridCellSize && this.gridCellSize !== 0\n  }\n\n  /*\n   * identify and populate the 'internal' vertex points, which is zoom-level specfic\n   */\n\n  createInternalVertexPoints () {\n    this.internalVertexPoints = []\n\n    for (var i in this.graph.edgeGroups) {\n      var edgeGroup = this.graph.edgeGroups[i]\n\n      var wlen = edgeGroup.getWorldLength()\n\n      var splitPoints = []\n\n      // compute the maximum number of internal points for this edge to add as graph vertices\n      if (edgeGroup.hasTransit()) {\n        var vertexFactor = this.internalVertexFactor //! edgeGroup.hasTransit() ? 1 : this.internalVertexFactor;\n        var newVertexCount = Math.floor(wlen / vertexFactor)\n\n        // get the priority queue of the edge's internal points\n        var pq = edgeGroup.getInternalVertexPQ()\n\n        // pull the 'best' points from the queue until we reach the maximum\n        while (splitPoints.length < newVertexCount && pq.size() > 0) {\n          var el = pq.deq()\n          splitPoints.push(el.point)\n        }\n      }\n\n      // perform the split operation (if needed)\n      if (splitPoints.length > 0) {\n        for (var e = 0; e < edgeGroup.edges.length; e++) {\n          var edge = edgeGroup.edges[e]\n          this.graph.splitEdgeAtInternalPoints(edge, splitPoints)\n        }\n      } else if (edgeGroup.hasTransit()) {\n        // special case: transit edge with no internal vertices (i.e. intermediate stops)\n        edgeGroup.edges.forEach(edge => {\n          if (edge.pointGeom && edge.pointGeom.length > 0) {\n            edge.geomCoords = edge.pointGeom[0].slice(0)\n          }\n        })\n      }\n    }\n  }\n\n  updateGeometry () {\n    // clear the stop render data\n    // for (var key in this.stops) this.stops[key].renderData = [];\n\n    this.graph.vertices.forEach(function (vertex) {\n      // vertex.snapped = false;\n      vertex.point.clearRenderData()\n    })\n\n    // refresh the edge-based points\n    this.graph.edges.forEach(function (edge) {\n      edge.pointArray.forEach(function (point) {\n        point.clearRenderData()\n      })\n    })\n\n    this.renderedEdges.forEach(function (rEdge) {\n      rEdge.clearOffsets()\n    })\n\n    // if (snapGrid)\n    // if(this.gridCellSize && this.gridCellSize !== 0) this.graph.snapToGrid(this.gridCellSize);\n\n    // this.fixPointOverlaps();\n\n    this.graph.calculateGeometry(this.gridCellSize, this.angleConstraint)\n\n    this.graph.apply2DOffsets(this)\n  }\n\n  applyZoomFactors (factors) {\n    this.gridCellSize = factors.gridCellSize\n    this.internalVertexFactor = factors.internalVertexFactor\n    this.angleConstraint = factors.angleConstraint\n    this.mergeVertexThreshold = factors.mergeVertexThreshold\n    this.useGeographicRendering = factors.useGeographicRendering\n  }\n\n  /**\n   *\n   */\n\n  processSegment (segment) {\n    // iterate through this pattern's stops, associating stops/patterns with\n    // each other and initializing the adjacentStops table\n    var previousStop = null\n    for (var i = 0; i < segment.points.length; i++) {\n      var point = segment.points[i]\n      point.used = true\n\n      // called for each pair of adjacent stops in sequence\n      if (previousStop && point.getType() === 'STOP') {\n        this.addStopAdjacency(point.getId(), previousStop.getId())\n        this.addStopAdjacency(previousStop.getId(), point.getId())\n      }\n\n      previousStop = (point.getType() === 'STOP') ? point : null\n\n      // add the start and end points to the vertexStops collection\n      var startPoint = segment.points[0]\n      this.addVertexPoint(startPoint)\n      startPoint.isSegmentEndPoint = true\n\n      var endPoint = segment.points[segment.points.length - 1]\n      this.addVertexPoint(endPoint)\n      endPoint.isSegmentEndPoint = true\n    }\n  }\n\n  /**\n   * Helper function for stopAjacency table\n   *\n   * @param {Stop} adjacent stops list\n   * @param {Stop} stopA\n   * @param {Stop} stopB\n   */\n\n  addStopAdjacency (stopIdA, stopIdB) {\n    if (!this.adjacentStops[stopIdA]) this.adjacentStops[stopIdA] = []\n    if (this.adjacentStops[stopIdA].indexOf(stopIdB) === -1) this.adjacentStops[stopIdA].push(stopIdB)\n  }\n\n  /**\n   * Populate the graph edges\n   */\n\n  populateGraphEdges () {\n    // vertex associated with the last vertex point we passed in this sequence\n    var lastVertex = null\n\n    // collection of 'internal' (i.e. non-vertex) points passed\n    // since the last vertex point\n    var internalPoints = []\n\n    forEach(this.paths, (path) => {\n      forEach(path.segments, (segment) => {\n        lastVertex = null\n\n        var streetEdgeIndex = 0\n\n        // for transit segments, see if there is a pattern with inter-stop geometry defined\n        var representativePattern = null\n        if (segment.type === 'TRANSIT') {\n          for (var i = 0; i < segment.patternGroup.patterns.length; i++) {\n            var pattern = segment.patternGroup.patterns[i]\n            if (pattern.interStopGeometry && pattern.interStopGeometry.length === pattern.stops.length - 1) {\n              representativePattern = pattern\n              break\n            }\n          }\n        }\n\n        /**\n         *  geomCoords: The geographic coordinates for the graph edge currently\n         *  being constructed, used when rendering edges in \"real-world\" (i.e.\n         *  non-schematic) mode. geomCoords data is only initialized here for\n         *  street-based segments, using the segment's embedded street geometry\n         *  data (if provided).\n         */\n        var geomCoords = []\n\n        /**\n         *  pointGeom: An array of point-specific geometry (i.e. the alignment\n         *  connecting this point to the following point in the containing\n         *  segment's point sequence. Currently applies to transit segments only.\n         *  pointGeom data is converted to geomCoords for rendering in the\n         *  splitEdgeAtInternalPoints method of NetworkGraph\n         */\n        var pointGeom = []\n\n        forEach(segment.points, (point, index) => {\n          if (segment.streetEdges) { // street-based segment with street-edge geometry\n            for (var i = streetEdgeIndex; i < segment.streetEdges.length; i++) {\n              if (index === 0) break\n\n              geomCoords = geomCoords.concat(geomCoords.length > 0 ? segment.streetEdges[i].worldCoords.slice(1) : segment.streetEdges[i].worldCoords)\n              if (segment.streetEdges[i].toTurnPoint === point) {\n                streetEdgeIndex = i + 1\n                break\n              }\n            }\n          } else if (representativePattern) { // transit-based segment with known geometry\n            var fromIndex = segment.patternGroup.getFromIndex(representativePattern)\n\n            // ignore the first stop, since the geometry at this index represents\n            // the alignment leading into that stop\n            if (index > 0) {\n              // add the alignment extending from this stop to the pointGeom array\n              var geom = representativePattern.interStopGeometry[fromIndex + index - 1]\n              pointGeom.push(geom)\n            }\n          }\n\n          if (point.multipoint) point = point.multipoint\n\n          if (point.graphVertex) { // this is a vertex point\n            if (lastVertex !== null) {\n              if (lastVertex.point === point) return\n\n              // see if an equivalent graph edge already exists\n              var fromVertex = lastVertex\n              var toVertex = point.graphVertex\n              var edge = this.graph.getEquivalentEdge(internalPoints, fromVertex, toVertex)\n\n              // create a new graph edge if necessary\n              if (!edge) {\n                edge = this.graph.addEdge(internalPoints, fromVertex, toVertex, segment.getType())\n                if (geomCoords && geomCoords.length > 0) edge.geomCoords = geomCoords\n                if (pointGeom && pointGeom.length > 0) edge.pointGeom = pointGeom\n              }\n\n              // associate the graph edge and path segment with each other\n              segment.addEdge(edge, fromVertex)\n              edge.addPathSegment(segment)\n\n              // reset the geomCoords and pointGeom arrays for the next edge\n              geomCoords = []\n              pointGeom = []\n            }\n\n            lastVertex = point.graphVertex\n            internalPoints = []\n          } else { // this is an internal point\n            internalPoints.push(point)\n          }\n        })\n      })\n    })\n  }\n\n  createGraphEdge (segment, fromVertex, toVertex, internalPoints, geomCoords) {\n    var edge = this.graph.getEquivalentEdge(internalPoints, fromVertex, toVertex)\n\n    if (!edge) {\n      edge = this.graph.addEdge(internalPoints, fromVertex, toVertex, segment.getType())\n\n      // calculate the angle and apply to edge stops\n      /* var dx = fromVertex.x - toVertex.x;\n      var dy = fromVertex.y - toVertex.y;\n      var angle = Math.atan2(dy, dx) * 180 / Math.PI;\n      point.angle = lastVertex.point.angle = angle;\n      for (var is = 0; is < internalPoints.length; is++) {\n        internalPoints[is].angle = angle;\n      } */\n\n      if (geomCoords) edge.geomCoords = geomCoords\n\n      debug('--- created edge ' + edge.toString())\n    }\n\n    segment.addEdge(edge, fromVertex)\n    edge.addPathSegment(segment)\n  }\n\n  annotateTransitPoints () {\n    this.paths.forEach(function (path) {\n      var transitSegments = []\n      path.segments.forEach(function (pathSegment) {\n        if (pathSegment.type === 'TRANSIT') transitSegments.push(pathSegment)\n      })\n\n      path.segments.forEach(function (pathSegment) {\n        if (pathSegment.type === 'TRANSIT') {\n          // if first transit segment in path, mark 'from' endpoint as board point\n          if (transitSegments.indexOf(pathSegment) === 0) {\n            pathSegment.points[0].isBoardPoint = true\n\n            // if there are additional transit segments, mark the 'to' endpoint as a transfer point\n            if (transitSegments.length > 1) pathSegment.points[pathSegment.points.length - 1].isTransferPoint = true\n\n          // if last transit segment in path, mark 'to' endpoint as alight point\n          } else if (transitSegments.indexOf(pathSegment) === transitSegments.length - 1) {\n            pathSegment.points[pathSegment.points.length - 1].isAlightPoint = true\n\n            // if there are additional transit segments, mark the 'from' endpoint as a transfer point\n            if (transitSegments.length > 1) pathSegment.points[0].isTransferPoint = true\n\n          // if this is an 'internal' transit segment, mark both endpoints as transfer points\n          } else if (transitSegments.length > 2) {\n            pathSegment.points[0].isTransferPoint = true\n            pathSegment.points[pathSegment.points.length - 1].isTransferPoint = true\n          }\n        }\n      })\n    })\n  }\n\n  initPlaceAdjacency () {\n    forEach(Object.values(this.places), place => {\n      if (!place.graphVertex) return\n      forEach(place.graphVertex.incidentEdges(), edge => {\n        const oppVertex = edge.oppositeVertex(place.graphVertex)\n        if (oppVertex.point) {\n          oppVertex.point.adjacentPlace = place\n        }\n      })\n    })\n  }\n\n  createRenderedSegments () {\n    this.reLookup = {}\n    this.renderedEdges = []\n    this.renderedSegments = []\n\n    for (var patternId in this.patterns) {\n      this.patterns[patternId].renderedEdges = []\n    }\n\n    forEach(this.paths, path => {\n      forEach(path.segments, pathSegment => {\n        pathSegment.renderedSegments = []\n\n        if (pathSegment.type === 'TRANSIT') {\n          // create a RenderedSegment for each pattern, except for buses which are collapsed to a single segment\n          var busPatterns = []\n          forEach(pathSegment.getPatterns(), pattern => {\n            if (pattern.route.route_type === 3) busPatterns.push(pattern)\n            else this.createRenderedSegment(pathSegment, [pattern])\n          })\n          if (busPatterns.length > 0) {\n            this.createRenderedSegment(pathSegment, busPatterns)\n          }\n        } else { // non-transit segments\n          this.createRenderedSegment(pathSegment)\n        }\n      })\n    })\n\n    this.renderedEdges.sort(function (a, b) { // process render transit segments before walk\n      if (a.getType() === 'WALK') return 1\n      if (b.getType() === 'WALK') return -1\n    })\n  }\n\n  createRenderedSegment (pathSegment, patterns) {\n    var rSegment = new RenderedSegment(pathSegment)\n\n    forEach(pathSegment.edges, edge => {\n      var rEdge = this.createRenderedEdge(pathSegment, edge.graphEdge, edge.forward, patterns)\n      rSegment.addRenderedEdge(rEdge)\n    })\n    if (patterns) {\n      rSegment.patterns = patterns\n      rSegment.mode = patterns[0].route.route_type\n    }\n\n    pathSegment.addRenderedSegment(rSegment)\n  }\n\n  createRenderedEdge (pathSegment, gEdge, forward, patterns) {\n    var rEdge\n\n    // construct the edge key, disregarding mode qualifiers (e.g. \"_RENT\")\n    var type = pathSegment.getType().split('_')[0]\n    var key = gEdge.id + (forward ? 'F' : 'R') + '_' + type\n\n    // for non-bus transit edges, append an exemplar pattern ID to the key\n    if (patterns && patterns[0].route.route_type !== 3) {\n      key += '_' + patterns[0].getId()\n    }\n\n    // see if this r-edge already exists\n    if (key in this.reLookup) {\n      rEdge = this.reLookup[key]\n    } else { // if not, create it\n      rEdge = new RenderedEdge(gEdge, forward, type, this.useGeographicRendering)\n      if (patterns) {\n        forEach(patterns, pattern => {\n          pattern.addRenderedEdge(rEdge)\n          rEdge.addPattern(pattern)\n        })\n        rEdge.mode = patterns[0].route.route_type\n      }\n      rEdge.points.push(gEdge.fromVertex.point)\n      rEdge.points.push(gEdge.toVertex.point)\n      gEdge.addRenderedEdge(rEdge)\n      rEdge.addPathSegment(pathSegment)\n\n      this.renderedEdges.push(rEdge)\n      this.reLookup[key] = rEdge\n    }\n    return rEdge\n  }\n\n  addVertexPoint (point) {\n    if (this.baseVertexPoints.indexOf(point) !== -1) return\n    this.baseVertexPoints.push(point)\n  }\n}\n\n/**\n * Mixin `Emitter`\n */\n\nEmitter(Network.prototype)\n"]}