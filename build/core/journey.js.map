{"version":3,"sources":["journey.js"],"names":["Journey","data","network","key","path","segments","segmentInfo","pathSegment","type","journeySegment","patterns","patternInfo","addPattern","pattern_id","from_stop_index","to_stop_index","streetEdges","from","to","stop_id","points","push","getEndPoint","length","lastTurnPoint","i","streetEdgeId","streetEdge","id","fromTurnPoint","lastIndex","latLons","turnPoint","getTurnPoint","lat","lon","worldX","worldCoords","worldY","toTurnPoint","addSegment","journey_id","pointInfo","places","place_id","stops","turnPointInfo","turnPoints"],"mappings":"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","file":"journey.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport PathSegment from './pathsegment'\nimport NetworkPath from './path'\nimport TurnPoint from '../point/turn'\n\n/**\n * Journey\n */\nexport default class Journey {\n  constructor (data, network) {\n    this.network = network\n\n    for (var key in data) {\n      this[key] = data[key]\n    }\n\n    this.path = new NetworkPath(this)\n\n    forEach(this.segments, (segmentInfo) => {\n      var pathSegment = new PathSegment(segmentInfo.type, this.path)\n      pathSegment.journeySegment = segmentInfo\n\n      if (segmentInfo.type === 'TRANSIT') {\n        if (segmentInfo.patterns) {\n          forEach(segmentInfo.patterns, (patternInfo) => {\n            pathSegment.addPattern(network.patterns[patternInfo.pattern_id],\n              patternInfo.from_stop_index, patternInfo.to_stop_index)\n          })\n        } else if (segmentInfo.pattern_id) { // legacy support for single-pattern journey segments\n          pathSegment.addPattern(network.patterns[segmentInfo.pattern_id],\n            segmentInfo.from_stop_index, segmentInfo.to_stop_index)\n        }\n      } else { // non-transit segment\n        var streetEdges = []\n        // screen out degenerate transfer segments\n        if (segmentInfo.from.type === 'STOP' && segmentInfo.to.type === 'STOP' &&\n          segmentInfo.from.stop_id === segmentInfo.to.stop_id) return\n\n        pathSegment.points.push(getEndPoint(segmentInfo.from, network))\n        if (segmentInfo.streetEdges && segmentInfo.streetEdges.length > 0) {\n          var lastTurnPoint = null\n\n          for (var i = 0; i < segmentInfo.streetEdges.length; i++) {\n            var streetEdgeId = segmentInfo.streetEdges[i]\n            var streetEdge = network.streetEdges[streetEdgeId]\n            streetEdge.id = streetEdgeId\n            streetEdges.push(streetEdge)\n            if (i >= segmentInfo.streetEdges.length - 1) continue\n\n            if (lastTurnPoint) streetEdge.fromTurnPoint = lastTurnPoint\n            var lastIndex = streetEdge.length - 1\n\n            // screen out degenerate edges\n            if (streetEdge.latLons[0][0] === streetEdge.latLons[lastIndex][0] &&\n              streetEdge.latLons[0][1] === streetEdge.latLons[lastIndex][1]) {\n              continue\n            }\n\n            // create a TurnPoint for the 'from' point of this edge\n            var turnPoint = getTurnPoint({\n              lat: streetEdge.latLons[lastIndex][0],\n              lon: streetEdge.latLons[lastIndex][1],\n              worldX: streetEdge.worldCoords[lastIndex][0],\n              worldY: streetEdge.worldCoords[lastIndex][1]\n            }, network)\n\n            // compute the angle represented by this turn point\n            /* turnPoint.turnAngle = Util.angleFromThreePoints(\n              streetEdge.worldCoords[0][0],\n              streetEdge.worldCoords[0][1],\n              streetEdge.worldCoords[lastIndex][0],\n              streetEdge.worldCoords[lastIndex][1],\n              nextEdge.worldCoords[nextEdge.length-1][0],\n              nextEdge.worldCoords[nextEdge.length-1][1]\n            ); */\n\n            pathSegment.points.push(turnPoint)\n            lastTurnPoint = streetEdge.toTurnPoint = turnPoint\n          }\n          pathSegment.streetEdges = streetEdges\n        }\n        pathSegment.points.push(getEndPoint(segmentInfo.to, network))\n      }\n      this.path.addSegment(pathSegment)\n    })\n  }\n\n  getElementId () {\n    return 'journey-' + this.journey_id\n  }\n}\n\nfunction getEndPoint (pointInfo, network) {\n  if (pointInfo.type === 'PLACE') {\n    return network.places[pointInfo.place_id]\n  } else if (pointInfo.type === 'STOP') {\n    return network.stops[pointInfo.stop_id]\n  }\n}\n\n/* utility function for creating non-duplicative TurnPoints */\n\nfunction getTurnPoint (turnPointInfo, network) {\n  var key = turnPointInfo.lat + '_' + turnPointInfo.lon\n  if (key in network.turnPoints) return network.turnPoints[key]\n  var turnPoint = new TurnPoint(turnPointInfo, key)\n  network.turnPoints[key] = turnPoint\n  // network.addVertexPoint(turnPoint);\n  return turnPoint\n}\n"]}