{"version":3,"sources":["interpolate-line.js"],"names":["points","newPoints","i","r","resampleSpacing","display","styler","compute","segments","segment","length","concat","resampleLine","join","renderData","arc","radius","theta","Math","PI","resampleArc","str","sweep","startPt","endPt","spacing","dx","dy","len","sqrt","sampledPts","l","t","push","ccw","abs","pt","x","y"],"mappings":"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","file":"interpolate-line.js","sourcesContent":["/**\n * Line interpolation utility function\n *\n * @param {Array} points\n */\n\nimport { pointAlongArc } from './index'\n\nexport default function (points) {\n  var newPoints, i, r\n\n  // determine if we need to resample the path (i.e. place new points at a regular\n  // interval for marker-based styling) based on styler settings\n  var resampleSpacing = this.display.styler.compute(this.display.styler.segments['marker-spacing'], this.display, this.segment)\n\n  // handle the case of a simple straight line\n  if (points.length === 2) {\n    if (resampleSpacing) {\n      newPoints = [points[0]]\n      newPoints = newPoints.concat(resampleLine(points[0], points[1],\n        resampleSpacing))\n      return newPoints.join(' ')\n    }\n    return points.join(' ')\n  }\n\n  // otherwise, assume a curved segment\n\n  if (resampleSpacing) {\n    newPoints = [points[0]]\n    for (i = 1; i < points.length; i++) {\n      if (this.segment.renderData[i].arc) {\n        // debug(this.renderData[i]);\n        // var r = this.renderData[i].radius;\n        // var sweep = (this.renderData[i].arc > 0) ? 0 : 1;\n        // str += 'A ' + r + ',' + r + ' 0 0 ' + sweep + ' ' + points[i];\n        r = this.segment.renderData[i].radius\n        var theta = this.segment.renderData[i].arc * Math.PI / 180\n        newPoints = newPoints.concat(resampleArc(points[i - 1], points[i], r,\n          theta, -this.segment.renderData[i].arc, resampleSpacing))\n      } else {\n        newPoints = newPoints.concat(resampleLine(points[i - 1], points[i],\n          resampleSpacing))\n      }\n    }\n    return newPoints.join(' ')\n  } else {\n    var str = points[0]\n    for (i = 1; i < points.length; i++) {\n      if (this.segment.renderData[i].arc) {\n        r = this.segment.renderData[i].radius\n        var sweep = (this.segment.renderData[i].arc > 0) ? 0 : 1\n        str += 'A ' + r + ',' + r + ' 0 0 ' + sweep + ' ' + points[i]\n      } else {\n        str += 'L' + points[i]\n      }\n    }\n    return str\n  }\n}\n\nfunction resampleLine (startPt, endPt, spacing) {\n  var dx = endPt[0] - startPt[0]\n  var dy = endPt[1] - startPt[1]\n  var len = Math.sqrt(dx * dx + dy * dy)\n\n  var sampledPts = [startPt]\n  for (var l = spacing; l < len; l += spacing) {\n    var t = l / len\n    sampledPts.push([startPt[0] + t * dx, startPt[1] + t * dy])\n  }\n\n  sampledPts.push(endPt)\n\n  return sampledPts\n}\n\nfunction resampleArc (startPt, endPt, r, theta, ccw, spacing) {\n  var len = r * Math.abs(theta)\n\n  var sampledPts = []\n  for (var l = spacing; l < len; l += spacing) {\n    var t = l / len\n    var pt = pointAlongArc(startPt[0], startPt[1], endPt[0], endPt[1], r,\n      Math.abs(theta), ccw, t)\n    sampledPts.push([pt.x, pt.y])\n  }\n\n  return sampledPts\n}\n"]}