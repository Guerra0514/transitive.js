{"version":3,"sources":["styler.js"],"names":["types","svgAttributes","Styler","styles","transitive","reset","load","i","type","key","Array","isArray","concat","rules","display","data","index","computed","self","rule","val","call","utils","undefined","attr","mode","modeStyles","segment","focused","isFocused","route","route_type","agency_id","route_id","route_short_name","route_long_name","pattern","addPattern","patterns","attrName","segments","isFunction","Object","prototype","toString"],"mappings":"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","file":"styler.js","sourcesContent":["import Route from '../core/route'\nimport RoutePattern from '../core/pattern'\nimport { otpModeToGtfsType } from '../util'\n\nimport styles from './styles'\n\n/**\n * Element Types\n */\n\nvar types = [\n  'labels',\n  'segments',\n  'segments_front',\n  'segments_halo',\n  'segment_labels',\n  'segment_label_containers',\n  'stops_merged',\n  'stops_pattern',\n  'places',\n  'places_icon',\n  'multipoints_merged',\n  'multipoints_pattern',\n  'wireframe_vertices',\n  'wireframe_edges'\n]\n\n/**\n * SVG attributes\n */\n\nvar svgAttributes = [\n  'height',\n  'target',\n  'title',\n  'width',\n  'y1',\n  'y2',\n  'x1',\n  'x2',\n  'cx',\n  'cy',\n  'dx',\n  'dy',\n  'rx',\n  'ry',\n  'd',\n  'r',\n  'y',\n  'x',\n  'transform'\n]\n\n/**\n * Styler object\n */\n\nexport default class Styler {\n  constructor (styles, transitive) {\n    //if (!(this instanceof Styler)) return new Styler(styles)\n    this.transitive = transitive\n\n    // reset styles\n    this.reset()\n\n    // load styles\n    if (styles) this.load(styles)\n  }\n\n  /**\n   * Clear all current styles\n   */\n\n  clear () {\n    for (var i in types) {\n      this[types[i]] = {}\n    }\n  }\n\n  /**\n   * Reset to the predefined styles\n   */\n\n  reset () {\n    for (var i in types) {\n      var type = types[i]\n      this[type] = Object.assign({}, styles[type] || {})\n      for (var key in this[type]) {\n        if (!Array.isArray(this[type][key])) this[type][key] = [this[type][key]]\n      }\n    }\n  }\n\n  /**\n   * Load rules\n   *\n   * @param {Object} a set of style rules\n   */\n\n  load (styles) {\n    for (var i in types) {\n      var type = types[i]\n      if (styles[type]) {\n        for (var key in styles[type]) {\n          this[type][key] = (this[type][key] || []).concat(styles[type][key])\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Compute a style rule based on the current display and data\n   *\n   * @param {Array} array of rules\n   * @param {Object} the Display object\n   * @param {Object} data associated with this object\n   * @param {Number} index of this object\n   */\n\n  compute (rules, display, data, index) {\n    var computed\n    var self = this\n    for (var i in rules) {\n      var rule = rules[i]\n      var val = (typeof rule === 'function')\n        ? rule.call(self, display, data, index, styles.utils)\n        : rule\n      if (val !== undefined && val !== null) computed = val\n    }\n    return computed\n  }\n\n  compute2 (type, attr, data, index) {\n    let computed\n    const rules = this[type][attr]\n    if (!rules) return null\n    for (const rule of rules) {\n      const val = (typeof rule === 'function')\n        ? rule.call(this, this.transitive.display, data, index, styles.utils)\n        : rule\n      if (val !== undefined && val !== null) computed = val\n    }\n    return computed\n  }\n\n\n  /**\n   * Return the collection of default segment styles for a mode.\n   *\n   * @param {String} an OTP mode string\n   */\n\n  getModeStyles (mode, display) {\n    var modeStyles = {}\n\n    // simulate a segment w/ the specified style\n    var segment = {\n      focused: true,\n      isFocused: function () {\n        return true\n      }\n    }\n\n    if (\n      mode === 'WALK' ||\n      mode === 'BICYCLE' ||\n      mode === 'BICYCLE_RENT' ||\n      mode === 'CAR' ||\n      mode === 'CAR_RENT' ||\n      mode === 'MICROMOBILITY' ||\n      mode === 'MICROMOBILITY_RENT'\n    ) {\n      segment.type = mode\n    } else { // assume a transit mode\n      segment.type = 'TRANSIT'\n      segment.mode = otpModeToGtfsType(mode)\n      var route = new Route({\n        route_type: segment.mode,\n        agency_id: '',\n        route_id: '',\n        route_short_name: '',\n        route_long_name: ''\n      })\n      var pattern = new RoutePattern({})\n      route.addPattern(pattern)\n      segment.patterns = [pattern]\n    }\n\n    for (var attrName in this.segments) {\n      var rules = this.segments[attrName]\n      for (var i in rules) {\n        var rule = rules[i]\n        var val = isFunction(rule)\n          ? rule.call(this, display, segment, 0, styles.utils)\n          : rule\n        if (val !== undefined && val !== null) {\n          modeStyles[attrName] = val\n        }\n      }\n    }\n\n    return modeStyles\n  }\n}\n\n/**\n * Is function?\n */\n\nfunction isFunction (val) {\n  return Object.prototype.toString.call(val) === '[object Function]'\n}\n"]}