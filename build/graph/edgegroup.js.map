{"version":3,"sources":["edgegroup.js"],"names":["EdgeGroup","fromVertex","toVertex","type","edges","commonPoints","worldLength","edge","push","edgeGroup","Math","max","getWorldLength","pointArray","slice","concat","filter","indexOf","pt","allPoints","point","pq","a","b","weight","i","length","getInternalVertexWeight","enq","index","x1","worldX","y1","worldY","x2","y2","x3","y3","inDist","outDist","theta","edgeLen","abs","PI","hasTransit","isNonTransitPath","maxAngle","getType","turnAngle"],"mappings":"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","file":"edgegroup.js","sourcesContent":["import PriorityQueue from 'priorityqueuejs'\n\nimport { distance, angleFromThreePoints } from '../util'\n\n/**\n *  A group of edges that share the same endpoint vertices\n */\n\nexport default class EdgeGroup {\n  constructor (fromVertex, toVertex, type) {\n    this.fromVertex = fromVertex\n    this.toVertex = toVertex\n    this.type = type\n    this.edges = []\n    this.commonPoints = null\n    this.worldLength = 0\n  }\n\n  addEdge (edge) {\n    this.edges.push(edge)\n    edge.edgeGroup = this\n\n    // update the groups worldLength\n    this.worldLength = Math.max(this.worldLength, edge.getWorldLength())\n\n    if (this.commonPoints === null) { // if this is first edge added, initialize group's commonPoint array to include all of edge's points\n      this.commonPoints = edge.pointArray.slice()\n    } else { // otherwise, update commonPoints array to only include those in added edge\n      this.commonPoints = this.commonPoints\n        .concat(edge.pointArray.filter(pt => this.commonPoints.indexOf(pt) !== -1))\n    }\n  }\n\n  getWorldLength () {\n    return this.worldLength\n  }\n\n  getInternalVertexPQ () {\n    // create an array of all points on the edge (endpoints and internal)\n    var allPoints = ([this.fromVertex.point]).concat(this.commonPoints, [this.toVertex\n      .point\n    ])\n\n    var pq = new PriorityQueue(function (a, b) {\n      return a.weight - b.weight\n    })\n\n    for (var i = 1; i < allPoints.length - 1; i++) {\n      var weight = this.getInternalVertexWeight(allPoints, i)\n      pq.enq({\n        weight: weight,\n        point: allPoints[i]\n      })\n    }\n\n    return pq\n  }\n\n  getInternalVertexWeight (pointArray, index) {\n    var x1 = pointArray[index - 1].worldX\n    var y1 = pointArray[index - 1].worldY\n    var x2 = pointArray[index].worldX\n    var y2 = pointArray[index].worldY\n    var x3 = pointArray[index + 1].worldX\n    var y3 = pointArray[index + 1].worldY\n\n    // the weighting function is a combination of:\n    // - the distances from this internal point to the two adjacent points, normalized for edge length (longer distances are prioritized)\n    // - the angle formed by this point and the two adjacent ones ('sharper' angles are prioritized)\n    var inDist = distance(x1, y1, x2, y2)\n    var outDist = distance(x2, y2, x3, y3)\n    var theta = angleFromThreePoints(x1, y1, x2, y2, x3, y3)\n    var edgeLen = this.getWorldLength()\n    var weight = inDist / edgeLen + outDist / edgeLen + Math.abs(Math.PI - theta) / Math.PI\n\n    return weight\n  }\n\n  hasTransit () {\n    for (var i = 0; i < this.edges.length; i++) {\n      if (this.edges[i].hasTransit()) return true\n    }\n    return false\n  }\n\n  isNonTransitPath () {\n    return (this.edges.length === 1 && this.edges[0].isNonTransitPath())\n  }\n\n  getTurnPoints (maxAngle) {\n    maxAngle = maxAngle || 0.75 * Math.PI\n    return this.commonPoints.filter(pt =>\n      pt.getType() === 'TURN' && Math.abs(pt.turnAngle) < maxAngle)\n  }\n}\n"]}