{"version":3,"sources":["graph.js"],"names":["debug","require","NetworkGraph","network","vertices","edges","edgeGroups","i","addVertex","worldX","worldY","xmax","xmin","ymax","ymin","vertex","Math","min","x","max","y","maxExtent","point","undefined","xy","forward","getLon","getLat","push","stops","from","to","segmentType","indexOf","edge","groupKey","transitive","options","groupEdges","getEdgeGroupKey","getId","fromVertex","toVertex","addEdge","edgeIndex","splice","pathSegments","segment","removeEdge","vertexArray","xTotal","yTotal","vertexGroups","getType","STOP","length","PLACE","MULTI","mergePoint","TURN","addPoint","stopVertex","mergedVertex","slice","replaceVertex","index","oldVertices","sort","a","b","pointArray","e","equal","reverse","points","subEdgePoints","newEdge","newEdgeInfoArr","geomCoords","pointGeom","concat","newVertex","graphVertex","isInternal","edgeGroup","type","copyPathSegments","graphEdge","indexInSegment","pathSegment","getEdgeIndex","insertEdgeAt","edgeInfo","containsSegmentEndPoint","opposites","pathSegmentBundles","pathSegmentIds","getPathSegmentIds","opp","oppositeVertex","key","edgeArr","mergeEdges","edge1","edge2","internalPoints","cellSize","coincidenceMap","nx","round","ny","vertexArr","mergeVertices","angleConstraint","calculateGeometry","origX","origY","xCoords","yCoords","v","mx","median","my","initComparisons","alignmentBundles","addToBundle","rEdge","alignmentId","bundle","range","getAlignmentRange","AlignmentBundle","bundleArr","rangeOverlaps","fromAlignmentId","getFromAlignmentId","toAlignmentId","getToAlignmentId","renderedEdges","bundleSorter","aId","patternIds","bId","aVector","getAlignmentVector","currentAlignmentId","bVector","isOutward","abCompId","bundleComparisons","baCompId","route","route_type","isForward","items","lw","bundleWidth","offset","patterns","pattern","offsetAlignment","incidentGraphEdges","incidentEdges","angleREdges","angle","incidentGraphEdge","fromAngle","toAngle","angleDeg","PI","rEdges","j","re1","re2","opp1","opp2","isCcw","s1Ext","findExtension","s2Ext","getInverse","storeComparison","s1","s2","s1Id","s2Id","Number","MAX_VALUE"],"mappings":"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","file":"graph.js","sourcesContent":["var debug = require('debug')('transitive:graph')\n\nimport d3 from 'd3'\nimport { forEach } from 'lodash'\n\nimport Edge from './edge'\nimport EdgeGroup from './edgegroup'\nimport Vertex from './vertex'\nimport MultiPoint from '../point/multipoint'\nimport { ccw, isOutwardVector, sm } from '../util'\n\n/**\n *  A graph representing the underlying 'wireframe' network\n */\n\nexport default class NetworkGraph {\n  constructor (network, vertices) {\n    this.network = network\n    this.edges = []\n    this.vertices = []\n\n    /**\n     *  Object mapping groups of edges that share the same two vertices.\n     *  - Key is string of format A_B, where A and B are vertex IDs and A < B\n     *  - Value is array of edges\n     */\n    this.edgeGroups = {}\n\n    // Add all base vertices\n    for (var i in vertices) this.addVertex(vertices[i], vertices[i].worldX, vertices[i].worldY)\n  }\n\n  /**\n   * Get the bounds of the graph in the graph's internal x/y coordinate space\n   *\n   * @return [[left, top], [right, bottom]]\n   */\n\n  bounds () {\n    var xmax = null\n    var xmin = null\n    var ymax = null\n    var ymin = null\n\n    for (var i in this.vertices) {\n      var vertex = this.vertices[i]\n      xmin = xmin ? Math.min(xmin, vertex.x) : vertex.x\n      xmax = xmax ? Math.max(xmax, vertex.x) : vertex.x\n      ymin = ymin ? Math.min(ymin, vertex.y) : vertex.y\n      ymax = ymax ? Math.max(ymax, vertex.y) : vertex.y\n    }\n\n    var maxExtent = 20037508.34\n    return [\n      [xmin || -maxExtent, ymin || -maxExtent],\n      [xmax || maxExtent, ymax || maxExtent]\n    ]\n  }\n\n  /**\n   * Add Vertex\n   */\n\n  addVertex (point, x, y) {\n    if (x === undefined || y === undefined) {\n      var xy = sm.forward([point.getLon(), point.getLat()])\n      x = xy[0]\n      y = xy[1]\n    }\n    var vertex = new Vertex(point, x, y)\n    this.vertices.push(vertex)\n    return vertex\n  }\n\n  /**\n   * Add Edge\n   */\n\n  addEdge (stops, from, to, segmentType) {\n    if (this.vertices.indexOf(from) === -1 || this.vertices.indexOf(to) === -1) {\n      debug('Error: Cannot add edge. Graph does not contain vertices.')\n      return\n    }\n\n    var edge = new Edge(stops, from, to)\n    this.edges.push(edge)\n    from.edges.push(edge)\n    to.edges.push(edge)\n\n    var groupKey = this.network.transitive.options.groupEdges\n      ? this.getEdgeGroupKey(edge, segmentType)\n      : edge.getId()\n\n    if (!(groupKey in this.edgeGroups)) {\n      this.edgeGroups[groupKey] = new EdgeGroup(edge.fromVertex, edge.toVertex,\n        segmentType)\n    }\n    this.edgeGroups[groupKey].addEdge(edge)\n\n    return edge\n  }\n\n  removeEdge (edge) {\n    // remove from the graph's edge collection\n    var edgeIndex = this.edges.indexOf(edge)\n    if (edgeIndex !== -1) this.edges.splice(edgeIndex, 1)\n\n    // remove from any associated path segment edge lists\n    forEach(edge.pathSegments, segment => {\n      segment.removeEdge(edge)\n    })\n\n    // remove from the endpoint vertex incidentEdge collections\n    edge.fromVertex.removeEdge(edge)\n    edge.toVertex.removeEdge(edge)\n  }\n\n  getEdgeGroup (edge) {\n    return this.edgeGroups[this.getEdgeGroupKey(edge)]\n  }\n\n  getEdgeGroupKey (edge, segmentType) {\n    return edge.fromVertex.getId() < edge.toVertex.getId()\n      ? segmentType + '_' + edge.fromVertex.getId() + '_' + edge.toVertex.getId()\n      : segmentType + '_' + edge.toVertex.getId() + '_' + edge.fromVertex.getId()\n  }\n\n  mergeVertices (vertexArray) {\n    var xTotal = 0\n    var yTotal = 0\n\n    var vertexGroups = {\n      'STOP': [],\n      'PLACE': [],\n      'TURN': [],\n      'MULTI': []\n    }\n    forEach(vertexArray, vertex => {\n      if (vertex.point.getType() in vertexGroups) {\n        vertexGroups[vertex.point.getType()].push(vertex)\n      }\n    })\n\n    // don't merge stops and places, or multiple places:\n    if ((vertexGroups.STOP.length > 0 && vertexGroups.PLACE.length > 0) ||\n      vertexGroups.PLACE.length > 1 ||\n      vertexGroups.MULTI.length > 0) return\n\n    let mergePoint\n\n    // if merging turns with a place, create a new merged vertex around the place\n    if (vertexGroups.PLACE.length === 1 && vertexGroups.TURN.length > 0) {\n      mergePoint = vertexGroups.PLACE[0].point\n    // if merging turns with a single place, create a new merged vertex around the stop\n    } else if (vertexGroups.STOP.length === 1 && vertexGroups.TURN.length > 0) {\n      mergePoint = vertexGroups.STOP[0].point\n    // if merging multiple stops, create a new MultiPoint vertex\n    } else if (vertexGroups.STOP.length > 1) {\n      mergePoint = new MultiPoint()\n      forEach(vertexGroups.STOP, stopVertex => {\n        mergePoint.addPoint(stopVertex.point)\n      })\n    // if merging multiple turns\n    } else if (vertexGroups.TURN.length > 1) {\n      mergePoint = vertexGroups.TURN[0].point\n    }\n\n    if (!mergePoint) return\n    var mergedVertex = new Vertex(mergePoint, 0, 0)\n\n    forEach(vertexArray, vertex => {\n      xTotal += vertex.x\n      yTotal += vertex.y\n\n      forEach(vertex.edges.slice(), edge => {\n        if (vertexArray.indexOf(edge.fromVertex) !== -1 &&\n            vertexArray.indexOf(edge.toVertex) !== -1) {\n          this.removeEdge(edge)\n          return\n        }\n        edge.replaceVertex(vertex, mergedVertex)\n        mergedVertex.addEdge(edge)\n      })\n      var index = this.vertices.indexOf(vertex)\n      if (index !== -1) this.vertices.splice(index, 1)\n    })\n\n    mergedVertex.x = xTotal / vertexArray.length\n    mergedVertex.y = yTotal / vertexArray.length\n    mergedVertex.oldVertices = vertexArray\n\n    this.vertices.push(mergedVertex)\n  }\n\n  sortVertices () {\n    this.vertices.sort((a, b) => {\n      if (a.point && a.point.getType() === 'PLACE') return -1\n      if (b.point && b.point.getType() === 'PLACE') return 1\n\n      if (a.point && a.point.getType() === 'MULTI') return -1\n      if (b.point && b.point.getType() === 'MULTI') return 1\n\n      if (a.point && a.point.getType() === 'STOP') return -1\n      if (b.point && b.point.getType() === 'STOP') return 1\n    })\n  }\n\n  /**\n   * Get the equivalent edge\n   */\n\n  getEquivalentEdge (pointArray, from, to) {\n    for (var e = 0; e < this.edges.length; e++) {\n      var edge = this.edges[e]\n      if (edge.fromVertex === from && edge.toVertex === to && pointArray.length ===\n        edge.pointArray.length && equal(pointArray, edge.pointArray)) {\n        return edge\n      }\n      if (edge.fromVertex === to && edge.toVertex === from && pointArray.length ===\n        edge.pointArray.length && equal(pointArray.slice(0).reverse(), edge.pointArray)) {\n        return edge\n      }\n    }\n  }\n\n  /**\n   *  Split a specified graph edge around a set of specified split points, where\n   *  all split points are internal points of the edge to be split. A set of N\n   *  valid split points will result in N+1 new edges. The original edge is\n   *  removed from the graph.\n   */\n\n  splitEdgeAtInternalPoints (edge, points) {\n    var subEdgePoints = []\n    var newEdge\n    var newEdgeInfoArr = []\n    var fromVertex = edge.fromVertex\n    var geomCoords = []\n\n    // iterate through the parent edge points, creating new sub-edges as needed\n    forEach(edge.pointArray, (point, i) => {\n      if (edge.pointGeom && i < edge.pointGeom.length) {\n        geomCoords = geomCoords.concat(edge.pointGeom[i])\n      }\n      if (points.indexOf(point) !== -1) { // we've reached a split point\n        var x = point.worldX\n        var y = point.worldY\n        var newVertex = point.graphVertex || this.addVertex(point, x, y)\n        newVertex.isInternal = true\n        newEdge = this.addEdge(subEdgePoints, fromVertex, newVertex, edge.edgeGroup\n          .type)\n        newEdge.isInternal = true\n        newEdge.copyPathSegments(edge)\n        newEdgeInfoArr.push({\n          graphEdge: newEdge,\n          fromVertex: fromVertex\n        })\n        if (geomCoords.length > 0) newEdge.geomCoords = geomCoords\n\n        subEdgePoints = []\n        fromVertex = newVertex\n        geomCoords = []\n      } else { // otherwise, this point becomes an internal point of the new edge currently being created\n        subEdgePoints.push(point)\n      }\n    })\n\n    // create the last sub-edge\n    newEdge = this.addEdge(subEdgePoints, fromVertex, edge.toVertex, edge.edgeGroup\n      .type)\n    newEdge.isInternal = true\n    newEdge.copyPathSegments(edge)\n    if (edge.pointGeom && edge.pointArray.length < edge.pointGeom.length) {\n      geomCoords = geomCoords.concat(edge.pointGeom[edge.pointArray.length])\n    }\n    if (geomCoords.length > 0) newEdge.geomCoords = geomCoords\n\n    newEdgeInfoArr.push({\n      graphEdge: newEdge,\n      fromVertex: fromVertex\n    })\n\n    // insert the new edge sequence into the affected segments\n    forEach(edge.pathSegments, pathSegment => {\n      var indexInSegment = pathSegment.getEdgeIndex(edge)\n      var forward = pathSegment.edges[indexInSegment].forward\n      var index = pathSegment.getEdgeIndex(edge)\n      forEach(forward ? newEdgeInfoArr : newEdgeInfoArr.reverse(), edgeInfo => {\n        pathSegment.insertEdgeAt(index, edgeInfo.graphEdge, forward ? edgeInfo.fromVertex : edgeInfo.toVertex)\n        index++\n      })\n    })\n\n    // remove the original edge from the graph\n    this.removeEdge(edge)\n  }\n\n  /* collapseTransfers = function(threshold) {\n    if(!threshold) return;\n    this.edges.forEach(function(edge) {\n      if (edge.getLength() > threshold ||\n        edge.fromVertex.point.containsFromPoint() ||\n        edge.fromVertex.point.containsToPoint() ||\n        edge.toVertex.point.containsFromPoint() ||\n        edge.toVertex.point.containsToPoint()) return;\n      //if(edge.fromVertex.point.getType() === 'PLACE' || edge.toVertex.point.getType() === 'PLACE') return;\n      var notTransit = true;\n      edge.pathSegments.forEach(function(segment) {\n        notTransit = notTransit && segment.type !== 'TRANSIT';\n      });\n      if (notTransit) {\n        this.mergeVertices([edge.fromVertex, edge.toVertex]);\n      }\n    }, this);\n  }; */\n\n  pruneVertices () {\n    forEach(this.vertices, vertex => {\n      if (vertex.point.containsSegmentEndPoint()) return\n\n      var opposites = []\n      var pathSegmentBundles = {} // maps pathSegment id list (string) to collection of edges (array)\n\n      forEach(vertex.edges, edge => {\n        var pathSegmentIds = edge.getPathSegmentIds()\n        if (!(pathSegmentIds in pathSegmentBundles)) pathSegmentBundles[pathSegmentIds] = []\n        pathSegmentBundles[pathSegmentIds].push(edge)\n        var opp = edge.oppositeVertex(vertex)\n        if (opposites.indexOf(opp) === -1) opposites.push(opp)\n      })\n\n      if (opposites.length !== 2) return\n\n      for (const key in pathSegmentBundles) {\n        const edgeArr = pathSegmentBundles[key]\n        if (edgeArr.length === 2) this.mergeEdges(edgeArr[0], edgeArr[1])\n      }\n    })\n  }\n\n  mergeEdges (edge1, edge2) {\n    // check for infinite recursion loop case\n    if (edge1.fromVertex === edge2.toVertex && edge2.fromVertex === edge1.toVertex) {\n      return\n    }\n\n    // reverse edges if necessary\n    if (edge1.fromVertex === edge2.toVertex) {\n      this.mergeEdges(edge2, edge1)\n      return\n    }\n\n    if (edge1.toVertex !== edge2.fromVertex) return // edges cannot be merged\n\n    var internalPoints = edge1.pointArray.concat(edge2.pointArray)\n\n    var newEdge = this.addEdge(internalPoints, edge1.fromVertex, edge2.toVertex,\n      edge1.edgeGroup.type)\n    newEdge.pathSegments = edge1.pathSegments\n    forEach(newEdge.pathSegments, segment => {\n      var i = segment.getEdgeIndex(edge1)\n      segment.insertEdgeAt(i, newEdge, newEdge.fromVertex)\n    })\n\n    // if both input edges are have coordinate geometry, merge the coords arrays in the new edge\n    if (edge1.geomCoords && edge2.geomCoords) {\n      newEdge.geomCoords = edge1.geomCoords.concat(edge2.geomCoords.length > 0\n        ? edge2.geomCoords.slice(1)\n        : [])\n    }\n\n    debug('merging:')\n    debug(edge1)\n    debug(edge2)\n    this.removeEdge(edge1)\n    this.removeEdge(edge2)\n  }\n\n  snapToGrid (cellSize) {\n    var coincidenceMap = {}\n    forEach(this.vertices, vertex => {\n      var nx = Math.round(vertex.x / cellSize) * cellSize\n      var ny = Math.round(vertex.y / cellSize) * cellSize\n      vertex.x = nx\n      vertex.y = ny\n\n      var key = nx + '_' + ny\n      if (!(key in coincidenceMap)) coincidenceMap[key] = [vertex]\n      else coincidenceMap[key].push(vertex)\n    })\n\n    forEach(coincidenceMap, vertexArr => {\n      if (vertexArr.length > 1) {\n        this.mergeVertices(vertexArr)\n      }\n    })\n  }\n\n  calculateGeometry (cellSize, angleConstraint) {\n    forEach(this.edges, edge => {\n      edge.calculateGeometry(cellSize, angleConstraint)\n    })\n  }\n\n  resetCoordinates () {\n    forEach(this.vertices, vertex => {\n      vertex.x = vertex.origX\n      vertex.y = vertex.origY\n    })\n  }\n\n  recenter () {\n    var xCoords = []\n    var yCoords = []\n    forEach(this.vertices, v => {\n      xCoords.push(v.x)\n      yCoords.push(v.y)\n    })\n\n    var mx = d3.median(xCoords)\n    var my = d3.median(yCoords)\n\n    forEach(this.vertices, v => {\n      v.x = v.x - mx\n      v.y = v.y - my\n    })\n  }\n\n  /** 2D line bundling & offsetting **/\n\n  apply2DOffsets () {\n    this.initComparisons()\n\n    var alignmentBundles = {} // maps alignment ID to array of range-bounded bundles on that alignment\n\n    const addToBundle = (rEdge, alignmentId) => {\n      var bundle\n\n      // compute the alignment range of the edge being bundled\n      var range = rEdge.graphEdge.getAlignmentRange(alignmentId)\n\n      // check if bundles already exist for this alignment\n      if (!(alignmentId in alignmentBundles)) { // if not, create new and add to collection\n        bundle = new AlignmentBundle()\n        bundle.addEdge(rEdge, range.min, range.max)\n        alignmentBundles[alignmentId] = [bundle] // new AlignmentBundle();\n      } else { // 1 or more bundles currently exist for this alignmentId\n        var bundleArr = alignmentBundles[alignmentId]\n\n        // see if the segment range overlaps with that of an existing bundle\n        for (var i = 0; i < bundleArr.length; i++) {\n          if (bundleArr[i].rangeOverlaps(range.min, range.max)) {\n            bundleArr[i].addEdge(rEdge, range.min, range.max)\n            return\n          }\n        }\n\n        // ..if not, create a new bundle\n        bundle = new AlignmentBundle()\n        bundle.addEdge(rEdge, range.min, range.max)\n        bundleArr.push(bundle)\n      }\n    }\n\n    forEach(this.edges, edge => {\n      var fromAlignmentId = edge.getFromAlignmentId()\n      var toAlignmentId = edge.getToAlignmentId()\n\n      forEach(edge.renderedEdges, rEdge => {\n        addToBundle(rEdge, fromAlignmentId)\n        addToBundle(rEdge, toAlignmentId)\n      })\n    })\n\n    const bundleSorter = (a, b) => {\n      var aId = a.patternIds || a.pathSegmentIds\n      var bId = b.patternIds || b.pathSegmentIds\n\n      var aVector = a.getAlignmentVector(this.currentAlignmentId)\n      var bVector = b.getAlignmentVector(this.currentAlignmentId)\n      var isOutward = (isOutwardVector(aVector) &&\n                       isOutwardVector(bVector)) ? 1 : -1\n\n      var abCompId = aId + '_' + bId\n      if (abCompId in this.bundleComparisons) {\n        return isOutward * this.bundleComparisons[abCompId]\n      }\n\n      var baCompId = bId + '_' + aId\n      if (baCompId in this.bundleComparisons) {\n        return isOutward * this.bundleComparisons[baCompId]\n      }\n\n      if (a.route && b.route && a.route.route_type !== b.route.route_type) {\n        return a.route.route_type > b.route.route_type ? 1 : -1\n      }\n\n      var isForward = (a.forward && b.forward) ? 1 : -1\n      return isForward * isOutward * (aId < bId ? -1 : 1)\n    }\n\n    forEach(Object.keys(alignmentBundles), alignmentId => {\n      var bundleArr = alignmentBundles[alignmentId]\n      forEach(bundleArr, bundle => {\n        if (bundle.items.length <= 1) return\n        var lw = 1.2\n        var bundleWidth = lw * (bundle.items.length - 1)\n\n        this.currentAlignmentId = alignmentId\n        bundle.items.sort(bundleSorter)\n        forEach(bundle.items, (rEdge, i) => {\n          var offset = (-bundleWidth / 2) + i * lw\n          if (rEdge.getType() === 'TRANSIT') {\n            forEach(rEdge.patterns, pattern => {\n              pattern.offsetAlignment(alignmentId, offset)\n            })\n          } else rEdge.offsetAlignment(alignmentId, offset)\n        })\n      })\n    })\n  }\n\n  /**\n   * Traverses the graph vertex-by-vertex, creating comparisons between all pairs of\n   * edges for which a topological relationship can be established.\n   */\n\n  initComparisons () {\n    this.bundleComparisons = {}\n\n    forEach(this.vertices, vertex => {\n      var incidentGraphEdges = vertex.incidentEdges()\n\n      var angleREdges = {}\n      forEach(incidentGraphEdges, incidentGraphEdge => {\n        var angle = (incidentGraphEdge.fromVertex === vertex) ? incidentGraphEdge.fromAngle : incidentGraphEdge.toAngle\n        var angleDeg = 180 * angle / Math.PI\n        if (!(angleDeg in angleREdges)) angleREdges[angleDeg] = []\n        angleREdges[angleDeg] = angleREdges[angleDeg].concat(incidentGraphEdge.renderedEdges)\n      })\n\n      forEach(angleREdges, rEdges => {\n        if (rEdges.length < 2) return\n        for (var i = 0; i < rEdges.length - 1; i++) {\n          for (var j = i + 1; j < rEdges.length; j++) {\n            var re1 = rEdges[i]\n            var re2 = rEdges[j]\n\n            var opp1 = re1.graphEdge.oppositeVertex(vertex)\n            var opp2 = re2.graphEdge.oppositeVertex(vertex)\n\n            var isCcw = ccw(opp1.x, opp1.y, vertex.x, vertex.y, opp2.x, opp2.y)\n\n            if (isCcw === 0) {\n              var s1Ext = re1.findExtension(opp1)\n              var s2Ext = re2.findExtension(opp2)\n              if (s1Ext) opp1 = s1Ext.graphEdge.oppositeVertex(opp1)\n              if (s2Ext) opp2 = s2Ext.graphEdge.oppositeVertex(opp2)\n              isCcw = ccw(opp1.x, opp1.y, vertex.x, vertex.y, opp2.x, opp2.y)\n            }\n\n            isCcw = getInverse(re1, re2, vertex) * isCcw\n\n            if (isCcw > 0) {\n              // e1 patterns are 'less' than e2 patterns\n              this.storeComparison(re1, re2)\n            }\n\n            if (isCcw < 0) {\n              // e2 patterns are 'less' than e2 patterns\n              this.storeComparison(re2, re1)\n            }\n          }\n        }\n      })\n    })\n  }\n\n  storeComparison (s1, s2) {\n    var s1Id = s1.patternIds || s1.pathSegmentIds\n    var s2Id = s2.patternIds || s2.pathSegmentIds\n    debug(`storing comparison: ${s1Id}  < ${s2Id}`)\n    this.bundleComparisons[`${s1Id}_${s2Id}`] = -1\n    this.bundleComparisons[`${s2Id}_${s1Id}`] = 1\n  }\n}\n\n/**\n *  AlignmentBundle class\n */\n\nclass AlignmentBundle {\n  constructor () {\n    this.items = [] // RenderedEdges\n    this.min = Number.MAX_VALUE\n    this.max = -Number.MAX_VALUE\n  }\n\n  addEdge (rEdge, min, max) {\n    if (this.items.indexOf(rEdge) === -1) {\n      this.items.push(rEdge)\n    }\n\n    this.min = Math.min(this.min, min)\n    this.max = Math.max(this.max, max)\n  }\n\n  rangeOverlaps (min, max) {\n    return this.min < max && min < this.max\n  }\n}\n\n/** Helper functions **/\n\nfunction getInverse (s1, s2, vertex) {\n  return (\n    (s1.graphEdge.toVertex === vertex && s2.graphEdge.toVertex === vertex) ||\n    (s1.graphEdge.toVertex === vertex && s2.graphEdge.fromVertex === vertex)\n  ) ? -1 : 1\n}\n\n/**\n * Check if arrays are equal\n */\n\nfunction equal (a, b) {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (var i in a) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n"]}