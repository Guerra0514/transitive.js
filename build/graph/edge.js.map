{"version":3,"sources":["edge.js"],"names":["edgeId","Edge","pointArray","fromVertex","toVertex","id","pathSegments","renderedEdges","dx","x","dy","y","Math","sqrt","worldLength","calculateWorldLengthAndMidpoint","worldMidpoint","allPoints","point","concat","i","length","worldX","worldY","distTraversed","dist","t","pointsBeforeMidpoint","pointsAfterMidpoint","elbow","oldVertex","newVertex","segment","push","baseEdge","addPathSegment","pathSegment","pathSegIds","map","sort","join","rEdge","indexOf","cellSize","angleConstraint","angleConstraintR","PI","fx","fy","tx","ty","midpoint","getWorldMidpoint","targetFromAngle","constrainedFromAngle","round","fromAngleDelta","abs","fvx","cos","fvy","sin","targetToAngle","constrainedToAngle","toAngleDelta","tvx","tvy","tol","v","equalVectors","isect","computeEndpointIntersection","intersect","u","adjustToAngle","adjustFromAngle","fromAngle","toAngle","calculateVectors","calculateAlignmentIds","isCcw","delta","fromVector","fromleftVector","fromRightVector","toVector","toleftVector","toRightVector","angle","angleD","ya","tan","fromAlignmentId","calculateAlignmentId","toAlignmentId","getType","alignmentId","p1","p2","min","max","substring","vertex","vector","aligned","hasCurvature","currentVector","getVector","curveAngle","calculateGeometry","fromOffsetPx","toOffsetPx","display","forward","coords","geomCoords","reverse","coord","rightVector","xOffset","yOffset","x1","xScale","y1","yScale","prevCoord","x0","y0","nextCoord","x2","y2","isBase","baseRenderCoords","calculateBaseRenderCoords","fromOffsetX","fromOffsetY","toOffsetX","toOffsetY","getRenderX","getRenderY","len","isStraight","ex","ey","ccw","angleR","getElbowAngle","rPx","getBaseRadiusPx","d","l1","l2","radius","arc","getRenderCoords","cx","cy","c","theta","asin","renderLength","coordAlongOffsetEdge","getRenderLength","loc","cur","t2","r","edge","pos","skip","labelPosition","path","segments","getId","toString"],"mappings":"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","file":"edge.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport { ccw, distance, getRadiusFromAngleChord, getVectorAngle, normalizeVector, pointAlongArc, rayIntersection } from '../util'\n\n/**\n * Edge\n */\n\nvar edgeId = 0\n\nexport default class Edge {\n  /**\n   * Initialize a new edge\n   * @constructor\n   * @param {Point[]} pointArray - the internal Points for this Edge\n   * @param {Vertex} fromVertex\n   * @param {Vertex} toVertex\n   */\n\n  constructor (pointArray, fromVertex, toVertex) {\n    this.id = edgeId++\n    this.pointArray = pointArray\n    this.fromVertex = fromVertex\n    this.toVertex = toVertex\n    this.pathSegments = []\n    this.renderedEdges = []\n  }\n\n  getId () {\n    return this.id\n  }\n\n  /**\n   *\n   */\n\n  getLength () {\n    var dx = this.toVertex.x - this.fromVertex.x\n    var dy = this.toVertex.y - this.fromVertex.y\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n\n  getWorldLength () {\n    if (!this.worldLength) this.calculateWorldLengthAndMidpoint()\n    return this.worldLength\n  }\n\n  getWorldMidpoint () {\n    if (!this.worldMidpoint) this.calculateWorldLengthAndMidpoint()\n    return this.worldMidpoint\n  }\n\n  calculateWorldLengthAndMidpoint () {\n    var allPoints = [this.fromVertex.point].concat(this.pointArray, [this.toVertex\n      .point\n    ])\n    this.worldLength = 0\n    for (var i = 0; i < allPoints.length - 1; i++) {\n      this.worldLength += distance(allPoints[i].worldX, allPoints[i].worldY,\n        allPoints[i + 1].worldX, allPoints[i + 1].worldY)\n    }\n\n    if (this.worldLength === 0) {\n      this.worldMidpoint = {\n        x: this.fromVertex.point.worldX,\n        y: this.fromVertex.point.worldY\n      }\n    } else {\n      var distTraversed = 0\n      for (i = 0; i < allPoints.length - 1; i++) {\n        var dist = distance(allPoints[i].worldX, allPoints[i].worldY,\n          allPoints[i + 1].worldX, allPoints[i + 1].worldY)\n        if ((distTraversed + dist) / this.worldLength >= 0.5) {\n          // find the position along this segment (0 <= t <= 1) where the edge midpoint lies\n          var t = (0.5 - distTraversed / this.worldLength) / (dist / this.worldLength)\n          this.worldMidpoint = {\n            x: allPoints[i].worldX + t * (allPoints[i + 1].worldX - allPoints[i].worldX),\n            y: allPoints[i].worldY + t * (allPoints[i + 1].worldY - allPoints[i].worldY)\n          }\n          this.pointsBeforeMidpoint = i\n          this.pointsAfterMidpoint = this.pointArray.length - i\n          break\n        }\n        distTraversed += dist\n      }\n    }\n  }\n\n  /**\n   *\n   */\n\n  isAxial () {\n    return (this.toVertex.x === this.fromVertex.x) || (this.toVertex.y === this.fromVertex\n      .y)\n  }\n\n  /**\n   *\n   */\n\n  hasCurvature () {\n    return this.elbow !== null\n  }\n\n  /**\n   *\n   */\n\n  replaceVertex (oldVertex, newVertex) {\n    if (oldVertex === this.fromVertex) this.fromVertex = newVertex\n    if (oldVertex === this.toVertex) this.toVertex = newVertex\n  }\n\n  /**\n   *  Add a path segment that traverses this edge\n   */\n\n  addPathSegment (segment) {\n    this.pathSegments.push(segment)\n  }\n\n  copyPathSegments (baseEdge) {\n    forEach(baseEdge.pathSegments, pathSegment => {\n      this.addPathSegment(pathSegment)\n    })\n  }\n\n  getPathSegmentIds (baseEdge) {\n    var pathSegIds = this.pathSegments.map(segment => segment.id)\n    pathSegIds.sort()\n    return pathSegIds.join(',')\n  }\n\n  /**\n   *\n   */\n\n  addRenderedEdge (rEdge) {\n    if (this.renderedEdges.indexOf(rEdge) !== -1) return\n    this.renderedEdges.push(rEdge)\n  }\n\n  /** internal geometry functions **/\n\n  calculateGeometry (cellSize, angleConstraint) {\n    // if(!this.hasTransit()) angleConstraint = 5;\n    angleConstraint = angleConstraint || 45\n\n    this.angleConstraintR = angleConstraint * Math.PI / 180\n\n    this.fx = this.fromVertex.point.worldX\n    this.fy = this.fromVertex.point.worldY\n    this.tx = this.toVertex.point.worldX\n    this.ty = this.toVertex.point.worldY\n\n    var midpoint = this.getWorldMidpoint()\n\n    var targetFromAngle = getVectorAngle(midpoint.x - this.fx, midpoint.y -\n      this.fy)\n    this.constrainedFromAngle = Math.round(targetFromAngle / this.angleConstraintR) *\n      this.angleConstraintR\n\n    var fromAngleDelta = Math.abs(this.constrainedFromAngle - targetFromAngle)\n    this.fvx = Math.cos(this.constrainedFromAngle)\n    this.fvy = Math.sin(this.constrainedFromAngle)\n\n    var targetToAngle = getVectorAngle(midpoint.x - this.tx, midpoint.y -\n      this.ty)\n\n    this.constrainedToAngle = Math.round(targetToAngle / this.angleConstraintR) *\n      this.angleConstraintR\n\n    var toAngleDelta = Math.abs(this.constrainedToAngle - targetToAngle)\n    this.tvx = Math.cos(this.constrainedToAngle)\n    this.tvy = Math.sin(this.constrainedToAngle)\n\n    var tol = 0.01\n    var v = normalizeVector({\n      x: (this.toVertex.x - this.fromVertex.x),\n      y: (this.toVertex.y - this.fromVertex.y)\n    })\n\n    // check if we need to add curvature\n    if (!equalVectors(this.fvx, this.fvy, -this.tvx, -this.tvy, tol) || !equalVectors(this.fvx, this.fvy, v.x, v.y, tol)) {\n      // see if the default endpoint angles produce a valid intersection\n      var isect = this.computeEndpointIntersection()\n\n      if (isect.intersect) { // if so, compute the elbow and we're done\n        this.elbow = {\n          x: this.fx + isect.u * this.fvx,\n          y: this.fy + isect.u * this.fvy\n        }\n      } else {\n   // if not, adjust the two endpoint angles until they properly intersect\n\n        // default test: compare angle adjustments (if significant difference)\n        if (Math.abs(fromAngleDelta - toAngleDelta) > 0.087) {\n          if (fromAngleDelta < toAngleDelta) {\n            this.adjustToAngle()\n          } else {\n            this.adjustFromAngle()\n          }\n        } else { // secondary test: look at distribution of shapepoints\n          if (this.pointsAfterMidpoint < this.pointsBeforeMidpoint) {\n            this.adjustToAngle()\n          } else {\n            this.adjustFromAngle()\n          }\n        }\n      }\n    }\n\n    this.fromAngle = this.constrainedFromAngle\n    this.toAngle = this.constrainedToAngle\n\n    this.calculateVectors()\n    this.calculateAlignmentIds()\n  }\n\n  /**\n   *  Adjust the 'to' endpoint angle by rotating it increments of angleConstraintR\n   *  until a valid intersection between the from and to endpoint rays is achieved.\n   */\n\n  adjustToAngle () {\n    var isCcw = ccw(this.fx, this.fy, (this.fx + this.fvx), (this.fy + this.fvy), this.tx, this.ty)\n    var delta = (isCcw > 0) ? this.angleConstraintR : -this.angleConstraintR\n    var i = 0\n    var isect\n    while (i++ < 100) {\n      this.constrainedToAngle += delta\n      this.tvx = Math.cos(this.constrainedToAngle)\n      this.tvy = Math.sin(this.constrainedToAngle)\n      isect = this.computeEndpointIntersection()\n      if (isect.intersect) break\n    }\n    this.elbow = {\n      x: this.fx + isect.u * this.fvx,\n      y: this.fy + isect.u * this.fvy\n    }\n  }\n\n  /**\n   *  Adjust the 'from' endpoint angle by rotating it increments of angleConstraintR\n   *  until a valid intersection between the from and to endpoint rays is achieved.\n   */\n\n  adjustFromAngle () {\n    var isCcw = ccw(this.tx, this.ty, (this.tx + this.tvx), (this.ty + this.tvy),\n      this.fx, this.fy)\n    var delta = (isCcw > 0) ? this.angleConstraintR : -this.angleConstraintR\n    var i = 0\n    var isect\n    while (i++ < 100) {\n      this.constrainedFromAngle += delta\n      this.fvx = Math.cos(this.constrainedFromAngle)\n      this.fvy = Math.sin(this.constrainedFromAngle)\n      isect = this.computeEndpointIntersection()\n      if (isect.intersect) break\n    }\n    this.elbow = {\n      x: this.fx + isect.u * this.fvx,\n      y: this.fy + isect.u * this.fvy\n    }\n  }\n\n  computeEndpointIntersection () {\n    return rayIntersection(this.fx, this.fy, this.fvx, this.fvy,\n      this.tx, this.ty, this.tvx, this.tvy)\n  }\n\n  calculateVectors (fromAngle, toAngle) {\n    this.fromVector = {\n      x: Math.cos(this.fromAngle),\n      y: Math.sin(this.fromAngle)\n    }\n\n    this.fromleftVector = {\n      x: -this.fromVector.y,\n      y: this.fromVector.x\n    }\n\n    this.fromRightVector = {\n      x: this.fromVector.y,\n      y: -this.fromVector.x\n    }\n\n    this.toVector = {\n      x: Math.cos(this.toAngle + Math.PI),\n      y: Math.sin(this.toAngle + Math.PI)\n    }\n\n    this.toleftVector = {\n      x: -this.toVector.y,\n      y: this.toVector.x\n    }\n\n    this.toRightVector = {\n      x: this.toVector.y,\n      y: -this.toVector.x\n    }\n  }\n\n  /**\n   *  Compute the 'alignment id', a string that uniquely identifies a line in\n   *  2D space given a point and angle relative to the x-axis.\n   */\n\n  calculateAlignmentId (x, y, angle) {\n    var angleD = Math.round(angle * 180 / Math.PI)\n    if (angleD > 90) angleD -= 180\n    if (angleD <= -90) angleD += 180\n\n    if (angleD === 90) {\n      return '90_x' + x\n    }\n\n    // calculate the y-axis crossing\n    var ya = Math.round(y - x * Math.tan(angle))\n    return angleD + '_y' + ya\n  }\n\n  calculateAlignmentIds () {\n    this.fromAlignmentId = this.calculateAlignmentId(this.fromVertex.x, this.fromVertex\n      .y, this.fromAngle)\n    this.toAlignmentId = this.calculateAlignmentId(this.toVertex.x, this.toVertex\n      .y, this.toAngle)\n  }\n\n  hasTransit (cellSize) {\n    // debug(this);\n    for (var i = 0; i < this.pathSegments.length; i++) {\n      if (this.pathSegments[i].getType() === 'TRANSIT') {\n        return true\n      }\n    }\n    return false\n  }\n\n  getFromAlignmentId () {\n    return this.fromAlignmentId\n  }\n\n  getToAlignmentId () {\n    return this.toAlignmentId\n  }\n\n  getAlignmentRange (alignmentId) {\n    var p1, p2\n    if (alignmentId === this.fromAlignmentId) {\n      p1 = this.fromVertex\n      p2 = this.elbow || this.toVertex\n    } else if (alignmentId === this.toAlignmentId) {\n      p1 = this.toVertex\n      p2 = this.elbow || this.fromVertex\n    } else {\n      return null\n    }\n\n    var min, max\n    if (alignmentId.substring(0, 2) === '90') {\n      min = Math.min(p1.y, p2.y)\n      max = Math.max(p1.y, p2.y)\n    } else {\n      min = Math.min(p1.x, p2.x)\n      max = Math.max(p1.x, p2.x)\n    }\n\n    return {\n      min: min,\n      max: max\n    }\n  }\n\n  align (vertex, vector) {\n    if (this.aligned || !this.hasCurvature()) return\n    var currentVector = this.getVector(vertex)\n    if (Math.abs(currentVector.x) !== Math.abs(vector.x) || Math.abs(\n      currentVector.y) !== Math.abs(vector.y)) {\n      this.curveAngle = -this.curveAngle\n      this.calculateGeometry()\n    }\n    this.aligned = true\n  }\n\n  getGeometricCoords (fromOffsetPx, toOffsetPx, display, forward) {\n    var coords = []\n\n    // reverse the coords array if needed\n    var geomCoords = forward ? this.geomCoords : this.geomCoords.concat().reverse()\n\n    forEach(geomCoords, (coord, i) => {\n      var fromVector = null\n      var toVector = null\n      var rightVector\n      var xOffset, yOffset\n      var x1 = display.xScale(coord[0])\n      var y1 = display.yScale(coord[1])\n\n      // calculate the vector leading in to this coordinate\n      if (i > 0) {\n        var prevCoord = geomCoords[i - 1]\n        var x0 = display.xScale(prevCoord[0])\n        var y0 = display.yScale(prevCoord[1])\n        if (x1 === x0 && y1 === y0) return\n\n        toVector = {\n          x: x1 - x0,\n          y: y1 - y0\n        }\n      }\n\n      // calculate the vector leading out from this coordinate\n      if (i < geomCoords.length - 1) {\n        var nextCoord = geomCoords[i + 1]\n        var x2 = display.xScale(nextCoord[0])\n        var y2 = display.yScale(nextCoord[1])\n        if (x2 === x1 && y2 === y1) return\n\n        fromVector = {\n          x: x2 - x1,\n          y: y2 - y1\n        }\n      }\n\n      if (fromVector && !toVector) { // the first point in the geomCoords sequence\n        rightVector = normalizeVector({\n          x: fromVector.y,\n          y: -fromVector.x\n        })\n        xOffset = fromOffsetPx * rightVector.x\n        yOffset = fromOffsetPx * rightVector.y\n      } else if (!fromVector && toVector) { // the last point in the geomCoords sequence\n        rightVector = normalizeVector({\n          x: toVector.y,\n          y: -toVector.x\n        })\n        xOffset = fromOffsetPx * rightVector.x\n        yOffset = fromOffsetPx * rightVector.y\n      } else { // an internal point\n        rightVector = normalizeVector({\n          x: fromVector.y,\n          y: -fromVector.x\n        })\n        xOffset = fromOffsetPx * rightVector.x\n        yOffset = fromOffsetPx * rightVector.y\n\n        // TODO: properly compute the offsets based on both vectors\n      }\n\n      coords.push({\n        x: x1 + xOffset,\n        y: y1 + yOffset\n      })\n    })\n    return coords\n  }\n\n  getRenderCoords (fromOffsetPx, toOffsetPx, display, forward) {\n    var isBase = (fromOffsetPx === 0 && toOffsetPx === 0)\n\n    if (!this.baseRenderCoords && !isBase) {\n      this.calculateBaseRenderCoords(display)\n    }\n\n    var fromOffsetX = fromOffsetPx * this.fromRightVector.x\n    var fromOffsetY = fromOffsetPx * this.fromRightVector.y\n\n    var toOffsetX = toOffsetPx * this.toRightVector.x\n    var toOffsetY = toOffsetPx * this.toRightVector.y\n\n    var fx = this.fromVertex.getRenderX(display) + fromOffsetX\n    var fy = this.fromVertex.getRenderY(display) - fromOffsetY\n    var fvx = this.fromVector.x\n    var fvy = -this.fromVector.y\n\n    var tx = this.toVertex.getRenderX(display) + toOffsetX\n    var ty = this.toVertex.getRenderY(display) - toOffsetY\n    var tvx = -this.toVector.x\n    var tvy = this.toVector.y\n\n    var coords = []\n\n    // append the first ('from') coordinate\n    coords.push({\n      x: forward ? fx : tx,\n      y: forward ? fy : ty\n    })\n\n    var len = null\n    var x1\n    var y1\n    var x2\n    var y2\n\n    // determine if this edge has an elbow, i.e. a bend in the middle\n    if ((isBase && !this.isStraight()) || (!isBase && this.baseRenderCoords.length ===\n      4)) {\n      var isect = rayIntersection(fx, fy, fvx, fvy, tx, ty, tvx, tvy)\n      if (isect.intersect) {\n        var u = isect.u\n        var ex = fx + fvx * u\n        var ey = fy + fvy * u\n\n        this.ccw = ccw(fx, fy, ex, ey, tx, ty)\n\n        // calculate the angle of the arc\n        var angleR = this.getElbowAngle()\n\n        // calculate the radius of the arc in pixels, taking offsets into consideration\n        var rPx = this.getBaseRadiusPx() - this.ccw * (fromOffsetPx + toOffsetPx) /\n          2\n\n        // calculate the distance from the elbow to place the arc endpoints in each direction\n        var d = rPx * Math.tan(angleR / 2)\n\n        // make sure the arc endpoint placement distance is not longer than the either of the\n        // elbow-to-edge-endpoint distances\n        var l1 = distance(fx, fy, ex, ey)\n        var l2 = distance(tx, ty, ex, ey)\n        d = Math.min(Math.min(l1, l2), d)\n\n        x1 = ex - this.fromVector.x * d\n        y1 = ey + this.fromVector.y * d\n\n        x2 = ex + this.toVector.x * d\n        y2 = ey - this.toVector.y * d\n\n        var radius = getRadiusFromAngleChord(angleR, distance(x1, y1,\n          x2, y2))\n        var arc = angleR * (180 / Math.PI) * (this.ccw < 0 ? 1 : -1)\n\n        if (forward) {\n          coords.push({\n            x: x1,\n            y: y1,\n            len: distance(fx, fy, x1, y1)\n          })\n\n          coords.push({\n            x: x2,\n            y: y2,\n            len: angleR * radius,\n            arc: arc,\n            radius: radius\n          })\n\n          len = distance(x2, y2, tx, ty)\n        } else { // backwards traversal\n          coords.push({\n            x: x2,\n            y: y2,\n            len: distance(tx, ty, x2, y2)\n          })\n\n          coords.push({\n            x: x1,\n            y: y1,\n            len: angleR * radius,\n            arc: -arc,\n            radius: radius\n          })\n\n          len = distance(x1, y1, fx, fy)\n        }\n      }\n    }\n\n    // if the length wasn't calculated during elbow-creation, do it now\n    if (len === null) len = distance(fx, fy, tx, ty)\n\n    // append the final ('to') coordinate\n    coords.push({\n      x: forward ? tx : fx,\n      y: forward ? ty : fy,\n      len: len\n    })\n\n    return coords\n  }\n\n  calculateBaseRenderCoords (display) {\n    this.baseRenderCoords = this.getRenderCoords(0, 0, display, true)\n  }\n\n  isStraight () {\n    var tol = 0.00001\n    return (Math.abs(this.fromVector.x - this.toVector.x) < tol &&\n      Math.abs(this.fromVector.y - this.toVector.y) < tol)\n  }\n\n  getBaseRadiusPx () {\n    return 15\n  }\n\n  getElbowAngle () {\n    var cx = this.fromVector.x - this.toVector.x\n    var cy = this.fromVector.y - this.toVector.y\n\n    var c = Math.sqrt(cx * cx + cy * cy) / 2\n\n    var theta = Math.asin(c)\n\n    return theta * 2\n  }\n\n  getRenderLength (display) {\n    if (!this.baseRenderCoords) this.calculateBaseRenderCoords(display)\n\n    if (!this.renderLength) {\n      this.renderLength = 0\n      for (var i = 1; i < this.baseRenderCoords.length; i++) {\n        this.renderLength += this.baseRenderCoords[i].len\n      }\n    }\n    return this.renderLength\n  }\n\n  /**\n   * Retrieve the coordinate located at a defined percentage along an Edge's length.\n   * @param {Number} t - a value between 0 and 1 representing the location of the\n   *   point to be computed\n   * @param {Object[]} coords - the offset coordinates computed for this edge.\n   * @param {Display} display\n   * @returns {Object} - the coordinate as an {x,y} Object\n   */\n\n  // TODO: not working for geographically-rendered edges?\n  coordAlongEdge (t, coords, display) {\n    if (!this.baseRenderCoords) {\n      this.calculateBaseRenderCoords(display)\n    }\n\n    if (coords.length !== this.baseRenderCoords.length) {\n      return this.coordAlongOffsetEdge(t, coords, display)\n    }\n\n    // get the length of this edge in screen units using the \"base\" (i.e. un-offset) render coords\n    var len = this.getRenderLength()\n\n    var loc = t * len // the target distance along the Edge's base geometry\n    var cur = 0 // our current location along the edge (in world units)\n\n    for (var i = 1; i < this.baseRenderCoords.length; i++) {\n      if (loc < cur + this.baseRenderCoords[i].len) {\n        var t2 = (loc - cur) / this.baseRenderCoords[i].len\n\n        if (coords[i].arc) {\n          var r = coords[i].radius\n          var theta = Math.PI * coords[i].arc / 180\n          var isCcw = ccw(coords[0].x, coords[0].y, coords[1].x, coords[1].y,\n            coords[2].x, coords[2].y)\n\n          return pointAlongArc(coords[1].x, coords[1].y, coords[2].x, coords[2].y, r, theta, isCcw, t2)\n        } else {\n          var dx = coords[i].x - coords[i - 1].x\n          var dy = coords[i].y - coords[i - 1].y\n\n          return {\n            x: coords[i - 1].x + dx * t2,\n            y: coords[i - 1].y + dy * t2\n          }\n        }\n      }\n      cur += this.baseRenderCoords[i].len\n    }\n  }\n\n  coordAlongOffsetEdge (t, coords, display) {\n    if (!this.baseRenderCoords) this.calculateBaseRenderCoords(display)\n\n    var len = 0\n    for (var i = 1; i < coords.length; i++) {\n      len += coords[i].len\n    }\n\n    var loc = t * len // the target distance along the Edge's base geometry\n    var cur = 0 // our current location along the edge (in world units)\n\n    for (i = 1; i < coords.length; i++) {\n      if (loc < cur + coords[i].len) {\n        var t2 = (loc - cur) / coords[i].len\n\n        if (coords[i].arc) { // arc segment\n          var r = coords[i].radius\n          var theta = Math.PI * coords[i].arc / 180\n          var isCcw = ccw(coords[0].x, coords[0].y, coords[1].x, coords[1].y,\n            coords[2].x, coords[2].y)\n\n          return pointAlongArc(coords[1].x, coords[1].y, coords[2].x, coords[2].y, r, theta, isCcw, t2)\n        } else { // straight segment\n          var dx = coords[i].x - coords[i - 1].x\n          var dy = coords[i].y - coords[i - 1].y\n\n          return {\n            x: coords[i - 1].x + dx * t2,\n            y: coords[i - 1].y + dy * t2\n          }\n        }\n      }\n      cur += coords[i].len\n    }\n  }\n\n  clearRenderData () {\n    this.baseRenderCoords = null\n    this.renderLength = null\n  }\n\n  getVector (vertex) {\n    if (vertex === this.fromVertex) return this.fromVector\n    if (vertex === this.toVertex) return this.toVector\n  }\n\n  /**\n   *  Gets the vertex opposite another vertex on an edge\n   */\n\n  oppositeVertex (vertex) {\n    if (vertex === this.toVertex) return this.fromVertex\n    if (vertex === this.fromVertex) return this.toVertex\n    return null\n  }\n\n  commonVertex (edge) {\n    if (this.fromVertex === edge.fromVertex || this.fromVertex === edge.toVertex) return this.fromVertex\n    if (this.toVertex === edge.fromVertex || this.toVertex === edge.toVertex) return this.toVertex\n    return null\n  }\n\n  /**\n   *\n   */\n\n  setPointLabelPosition (pos, skip) {\n    if (this.fromVertex.point !== skip) this.fromVertex.point.labelPosition = pos\n    if (this.toVertex.point !== skip) this.toVertex.point.labelPosition = pos\n\n    forEach(this.pointArray, point => {\n      if (point !== skip) point.labelPosition = pos\n    })\n  }\n\n  /**\n   *  Determines if this edge is part of a standalone, non-transit path\n   *  (e.g. a walk/bike/drive-only journey)\n   */\n\n  isNonTransitPath () {\n    return this.pathSegments.length === 1 && this.pathSegments[0] !== 'TRANSIT' &&\n      this.pathSegments[0].path.segments.length === 1\n  }\n\n  /**\n   *\n   */\n\n  toString () {\n    return 'Edge ' + this.getId() + ' (' + this.fromVertex.toString() + ' to ' +\n      this.toVertex.toString() + ')'\n  }\n}\n\n/** helper functions **/\n\nfunction equalVectors (x1, y1, x2, y2, tol) {\n  tol = tol || 0\n  return Math.abs(x1 - x2) < tol && Math.abs(y1 - y2) < tol\n}\n"]}