{"version":3,"sources":["labeler.js"],"names":["Labeler","transitive","clear","points","graph","vertices","point","vertex","getType","isSegmentEndPoint","push","sort","a","b","containsFromPoint","containsToPoint","quadtree","geom","extent","width","height","addPointsToQuadtree","mbbox","getMarkerBBox","addBBoxToQuadtree","renderSegments","segment","lw","style","compute","segments","display","parseFloat","substring","length","x","x1","x2","y","y1","y2","renderData","Math","min","abs","bbox","add","maxBBoxWidth","max","maxBBoxHeight","updateQuadtree","pointLabels","placePointLabels","segmentLabels","placeSegmentLabels","styler","placedLabels","labelText","label","getText","fontFamily","compute2","fontSize","textDimensions","text","lineHeight","textWidth","value","textHeight","orientations","labels","placedLabel","i","setOrientation","focused","labelAnchor","lx","ly","labelBBox","getBBox","overlaps","findOverlaps","setVisibility","placedLabelKeys","busRSegments","network","paths","path","getRenderedSegments","rSegment","type","mode","edgeGroups","getMode","concat","getLabelEdgeGroups","currentGroup","edgeGroup","labelTextArray","getLabelTextArray","labelTextIndex","getNextLabel","labelAnchors","getLabelAnchors","isInRange","conflicts","key","edgeIds","indexOf","constructSegmentLabel","renderedSegment","computeContainerDimensions","minX","minY","maxX","maxY","matchItems","visit","node","p","intersects","buffer","parent","patternIds"],"mappings":"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","file":"labeler.js","sourcesContent":["import { forEach } from 'lodash'\nimport measureText from 'measure-text'\nimport d3 from 'd3' // TODO: replace w/ other quadtree library\n\nimport SegmentLabel from './segmentlabel'\n\n/**\n * Labeler object\n */\n\nexport default class Labeler {\n  constructor (transitive) {\n    this.transitive = transitive\n    this.clear()\n  }\n\n  clear (transitive) {\n    this.points = []\n  }\n\n  updateLabelList (graph) {\n    this.points = []\n    forEach(graph.vertices, vertex => {\n      var point = vertex.point\n      if (point.getType() === 'PLACE' || point.getType() === 'MULTI' || (\n        point.getType() === 'STOP' && point.isSegmentEndPoint)) {\n        this.points.push(point)\n      }\n    })\n\n    this.points.sort((a, b) => {\n      if (a.containsFromPoint() || a.containsToPoint()) return -1\n      if (b.containsFromPoint() || b.containsToPoint()) return 1\n      return 0\n    })\n  }\n\n  updateQuadtree () {\n    this.quadtree = d3.geom.quadtree().extent([\n      [-this.width, -this.height],\n      [this.width * 2, this.height * 2]\n    ])([])\n\n    this.addPointsToQuadtree()\n    // this.addSegmentsToQuadtree();\n  }\n\n  addPointsToQuadtree () {\n    forEach(this.points, point => {\n      var mbbox = point.getMarkerBBox()\n      if (mbbox) this.addBBoxToQuadtree(point.getMarkerBBox())\n    })\n  }\n\n  addSegmentsToQuadtree () {\n    forEach(this.transitive.renderSegments, segment => {\n      if (segment.getType() !== 'TRANSIT') return\n\n      var lw = this.transitive.style.compute(this.transitive.style.segments['stroke-width'], this.transitive.display, segment)\n      lw = parseFloat(lw.substring(0, lw.length - 2), 10) - 2\n\n      var x, x1, x2, y, y1, y2\n      // debug(segment.toString());\n      if (segment.renderData.length === 2) { // basic straight segment\n        if (segment.renderData[0].x === segment.renderData[1].x) { // vertical\n          x = segment.renderData[0].x - lw / 2\n          y1 = segment.renderData[0].y\n          y2 = segment.renderData[1].y\n          this.addBBoxToQuadtree({\n            x: x,\n            y: Math.min(y1, y2),\n            width: lw,\n            height: Math.abs(y1 - y2)\n          })\n        } else if (segment.renderData[0].y === segment.renderData[1].y) { // horizontal\n          x1 = segment.renderData[0].x\n          x2 = segment.renderData[1].x\n          y = segment.renderData[0].y - lw / 2\n          this.addBBoxToQuadtree({\n            x: Math.min(x1, x2),\n            y: y,\n            width: Math.abs(x1 - x2),\n            height: lw\n          })\n        }\n      }\n\n      if (segment.renderData.length === 4) { // basic curved segment\n        if (segment.renderData[0].x === segment.renderData[1].x) { // vertical first\n          x = segment.renderData[0].x - lw / 2\n          y1 = segment.renderData[0].y\n          y2 = segment.renderData[3].y\n          this.addBBoxToQuadtree({\n            x: x,\n            y: Math.min(y1, y2),\n            width: lw,\n            height: Math.abs(y1 - y2)\n          })\n\n          x1 = segment.renderData[0].x\n          x2 = segment.renderData[3].x\n          y = segment.renderData[3].y - lw / 2\n          this.addBBoxToQuadtree({\n            x: Math.min(x1, x2),\n            y: y,\n            width: Math.abs(x1 - x2),\n            height: lw\n          })\n        } else if (segment.renderData[0].y === segment.renderData[1].y) { // horiz first\n          x1 = segment.renderData[0].x\n          x2 = segment.renderData[3].x\n          y = segment.renderData[0].y - lw / 2\n          this.addBBoxToQuadtree({\n            x: Math.min(x1, x2),\n            y: y,\n            width: Math.abs(x1 - x2),\n            height: lw\n          })\n\n          x = segment.renderData[3].x - lw / 2\n          y1 = segment.renderData[0].y\n          y2 = segment.renderData[3].y\n          this.addBBoxToQuadtree({\n            x: x,\n            y: Math.min(y1, y2),\n            width: lw,\n            height: Math.abs(y1 - y2)\n          })\n        }\n      }\n    })\n  }\n\n  addBBoxToQuadtree (bbox) {\n    if (bbox.x + bbox.width / 2 < 0 || bbox.x - bbox.width / 2 > this.width ||\n      bbox.y + bbox.height / 2 < 0 || bbox.y - bbox.height / 2 > this.height\n    ) return\n\n    this.quadtree.add([bbox.x + bbox.width / 2, bbox.y + bbox.height / 2,\n      bbox\n    ])\n\n    this.maxBBoxWidth = Math.max(this.maxBBoxWidth, bbox.width)\n    this.maxBBoxHeight = Math.max(this.maxBBoxHeight, bbox.height)\n  }\n\n  doLayout () {\n    this.width = this.transitive.display.width\n    this.height = this.transitive.display.height\n\n    this.maxBBoxWidth = 0\n    this.maxBBoxHeight = 0\n\n    this.updateQuadtree()\n\n    return {\n      pointLabels: this.placePointLabels(),\n      segmentLabels: this.placeSegmentLabels()\n    }\n  }\n\n  /** placePointLabels **/\n\n  placePointLabels () {\n    var styler = this.transitive.styler\n\n    const placedLabels = []\n    //var labeledPoints = []\n\n    forEach(this.points, point => {\n      var labelText = point.label.getText()\n      if (!labelText) return\n      point.label.fontFamily = styler.compute2('labels', 'font-family', point)\n      point.label.fontSize = styler.compute2('labels', 'font-size', point)\n      const textDimensions = measureText({\n        text: labelText,\n        fontSize: point.label.fontSize,\n        fontFamily: point.label.fontFamily || 'sans-serif',\n        lineHeight: 1.2\n      })\n      point.label.textWidth = textDimensions.width.value\n      point.label.textHeight = textDimensions.height.value\n\n      var orientations = styler.compute(\n        styler.labels.orientations,\n        this.transitive.display, {\n          point: point\n        }\n      )\n\n      var placedLabel = false\n      for (var i = 0; i < orientations.length; i++) {\n        point.label.setOrientation(orientations[i])\n        if (!point.focused) continue\n\n        if (!point.label.labelAnchor) continue\n\n        var lx = point.label.labelAnchor.x\n        var ly = point.label.labelAnchor.y\n\n        // do not place label if out of range\n        if (lx <= 0 || ly <= 0 || lx >= this.width || ly > this.height) continue\n\n        var labelBBox = point.label.getBBox()\n\n        var overlaps = this.findOverlaps(point.label, labelBBox)\n\n        // do not place label if it overlaps with others\n        if (overlaps.length > 0) continue\n\n        // if we reach this point, the label is good to place\n\n        point.label.setVisibility(true)\n        //labeledPoints.push(point)\n        placedLabels.push(point.label)\n\n        this.quadtree.add([labelBBox.x + labelBBox.width / 2, labelBBox.y +\n          labelBBox.height / 2, point.label\n        ])\n\n        this.maxBBoxWidth = Math.max(this.maxBBoxWidth, labelBBox.width)\n        this.maxBBoxHeight = Math.max(this.maxBBoxHeight, labelBBox.height)\n\n        placedLabel = true\n        break // do not consider any other orientations after places\n      } // end of orientation loop\n\n      // if label not placed at all, hide the element\n      if (!placedLabel) {\n        point.label.setVisibility(false)\n      }\n    })\n\n    return placedLabels\n  }\n\n  /** placeSegmentLabels **/\n\n  placeSegmentLabels () {\n    this.placedLabelKeys = []\n    const placedLabels = []\n\n    // collect the bus RenderSegments\n    var busRSegments = []\n    forEach(this.transitive.network.paths, path => {\n      forEach(path.getRenderedSegments(), rSegment => {\n        if (rSegment.type === 'TRANSIT' && rSegment.mode === 3) busRSegments.push(rSegment)\n      })\n    })\n\n    var edgeGroups = []\n    forEach(this.transitive.network.paths, path => {\n      forEach(path.segments, segment => {\n        if (segment.type === 'TRANSIT' && segment.getMode() === 3) {\n          edgeGroups = edgeGroups.concat(segment.getLabelEdgeGroups())\n        }\n      })\n    })\n\n    // iterate through the sequence collection, labeling as necessary\n    forEach(edgeGroups, edgeGroup => {\n      this.currentGroup = edgeGroup\n      // get the array of label strings to be places (typically the unique route short names)\n      this.labelTextArray = edgeGroup.getLabelTextArray()\n\n      // create the initial label for placement\n      this.labelTextIndex = 0\n\n      var label = this.getNextLabel() // this.constructSegmentLabel(rSegment, labelTextArray[labelTextIndex]);\n      if (!label) return\n\n      // iterate through potential anchor locations, attempting placement at each one\n      var labelAnchors = edgeGroup.getLabelAnchors(this.transitive.display,\n        label.textHeight * 1.5)\n      for (var i = 0; i < labelAnchors.length; i++) {\n        label.labelAnchor = labelAnchors[i]\n\n        // do not consider this anchor if it is out of the display range\n        if (!this.transitive.display.isInRange(label.labelAnchor.x,\n          label.labelAnchor.y)) continue\n\n        // check for conflicts with existing placed elements\n        var bbox = label.getBBox()\n        var conflicts = this.findOverlaps(label, bbox)\n\n        if (conflicts.length === 0) { // if no conflicts\n          // place the current label\n          placedLabels.push(label)\n          this.quadtree.add([label.labelAnchor.x, label.labelAnchor.y,\n            label\n          ])\n          label = this.getNextLabel()\n          if (!label) break\n        }\n      } // end of anchor iteration loop\n    }) // end of sequence iteration loop\n    return placedLabels\n  }\n\n  getNextLabel () {\n    while (this.labelTextIndex < this.labelTextArray.length) {\n      var labelText = this.labelTextArray[this.labelTextIndex]\n      var key = this.currentGroup.edgeIds + '_' + labelText\n      if (this.placedLabelKeys.indexOf(key) !== -1) {\n        this.labelTextIndex++\n        continue\n      }\n      var label = this.constructSegmentLabel(this.currentGroup.renderedSegment,\n        labelText)\n      this.placedLabelKeys.push(key)\n      this.labelTextIndex++\n      return label\n    }\n    return null\n  }\n\n  constructSegmentLabel (segment, labelText) {\n    var label = new SegmentLabel(segment, labelText)\n    var styler = this.transitive.styler\n    label.fontFamily = styler.compute2('segment_labels', 'font-family', segment)\n    label.fontSize = styler.compute2('segment_labels', 'font-size', segment)\n\n    const textDimensions = measureText({\n      text: labelText,\n      fontSize: label.fontSize + 'px',\n      fontFamily: label.fontFamily || 'sans-serif',\n      lineHeight: 1.2\n    })\n\n    label.textWidth = textDimensions.width.value\n    label.textHeight = textDimensions.height.value\n    label.computeContainerDimensions()\n\n    return label\n  }\n\n  findOverlaps (label, labelBBox) {\n    var minX = labelBBox.x - this.maxBBoxWidth / 2\n    var minY = labelBBox.y - this.maxBBoxHeight / 2\n    var maxX = labelBBox.x + labelBBox.width + this.maxBBoxWidth / 2\n    var maxY = labelBBox.y + labelBBox.height + this.maxBBoxHeight / 2\n    // debug('findOverlaps %s,%s %s,%s', minX,minY,maxX,maxY);\n\n    var matchItems = []\n    this.quadtree.visit((node, x1, y1, x2, y2) => {\n      var p = node.point\n      if ((p) && (p[0] >= minX) && (p[0] < maxX) && (p[1] >= minY) && (p[1] < maxY) && label.intersects(p[2])) {\n        matchItems.push(p[2])\n      }\n      return x1 > maxX || y1 > maxY || x2 < minX || y2 < minY\n    })\n    return matchItems\n  }\n\n  findNearbySegmentLabels (label, x, y, buffer) {\n    var minX = x - buffer\n    var minY = y - buffer\n    var maxX = x + buffer\n    var maxY = y + buffer\n    // debug('findNearby %s,%s %s,%s', minX,minY,maxX,maxY);\n\n    var matchItems = []\n    this.quadtree.visit((node, x1, y1, x2, y2) => {\n      var p = node.point\n      if ((p) && (p[0] >= minX) && (p[0] < maxX) && (p[1] >= minY) && (p[1] < maxY) && (p[2].parent) && (label.parent.patternIds === p[2].parent.patternIds)) {\n        matchItems.push(p[2])\n      }\n      return x1 > maxX || y1 > maxY || x2 < minX || y2 < minY\n    })\n    return matchItems\n  }\n}\n"]}