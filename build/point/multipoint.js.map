{"version":3,"sources":["multipoint.js"],"names":["MultiPoint","pointArray","points","addPoint","point","renderData","id","toPoint","fromPoint","patternStylerKey","getName","shortest","getType","length","i","containsSegmentEndPoint","containsBoardPoint","containsAlightPoint","containsTransferPoint","patterns","indexOf","pattern","push","getId","containsFromPoint","containsToPoint","calcWorldCoords","tx","ty","worldX","worldY","pointInfo","offsetX","offsetY","hasOffsetPoints","display","xArr","map","d","x","yArr","y","xMin","Math","min","xMax","max","yMin","yMax","r","width","height","drawRect","rx","ry","fill","stroke","markerBBox","mergedMarker","markerSvg","append","datum","owner","attr","focused","setFocused","callback","newStrokeColor","styler","compute","multipoints_merged","transition","style","call","label","runFocusTransition"],"mappings":"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","file":"multipoint.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport Point from './point'\n\n/**\n *  MultiPoint: a Point subclass representing a collection of multiple points\n *  that have been merged into one for display purposes.\n */\n\nexport default class MultiPoint extends Point {\n  constructor (pointArray) {\n    super()\n    this.points = []\n    if (pointArray) {\n      forEach(pointArray, point => {\n        this.addPoint(point)\n      })\n    }\n    this.renderData = []\n    this.id = 'multi'\n    this.toPoint = this.fromPoint = null\n\n    this.patternStylerKey = 'multipoints_pattern'\n  }\n\n  /**\n   * Get id\n   */\n\n  getId () {\n    return this.id\n  }\n\n  /**\n   * Get type\n   */\n\n  getType () {\n    return 'MULTI'\n  }\n\n  getName () {\n    if (this.fromPoint) return this.fromPoint.getName()\n    if (this.toPoint) return this.toPoint.getName()\n    var shortest = null\n    forEach(this.points, point => {\n      if (point.getType() === 'TURN') return\n      if (!shortest || point.getName().length < shortest.length) shortest = point.getName()\n    })\n\n    return shortest\n  }\n\n  containsSegmentEndPoint () {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i].containsSegmentEndPoint()) return true\n    }\n    return false\n  }\n\n  containsBoardPoint () {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i].containsBoardPoint()) return true\n    }\n    return false\n  }\n\n  containsAlightPoint () {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i].containsAlightPoint()) return true\n    }\n    return false\n  }\n\n  containsTransferPoint () {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i].containsTransferPoint()) return true\n    }\n    return false\n  }\n\n  containsFromPoint () {\n    return (this.fromPoint !== null)\n  }\n\n  containsToPoint () {\n    return (this.toPoint !== null)\n  }\n\n  getPatterns () {\n    var patterns = []\n\n    forEach(this.points, point => {\n      if (!point.patterns) return\n      forEach(point.patterns, pattern => {\n        if (patterns.indexOf(pattern) === -1) patterns.push(pattern)\n      })\n    })\n\n    return patterns\n  }\n\n  addPoint (point) {\n    if (this.points.indexOf(point) !== -1) return\n    this.points.push(point)\n    this.id += '-' + point.getId()\n    if (point.containsFromPoint()) { // getType() === 'PLACE' && point.getId() === 'from') {\n      this.fromPoint = point\n    }\n    if (point.containsToPoint()) { // getType() === 'PLACE' && point.getId() === 'to') {\n      this.toPoint = point\n    }\n    this.calcWorldCoords()\n  }\n\n  calcWorldCoords () {\n    var tx = 0\n    var ty = 0\n    forEach(this.points, point => {\n      tx += point.worldX\n      ty += point.worldY\n    })\n\n    this.worldX = tx / this.points.length\n    this.worldY = ty / this.points.length\n  }\n\n  /**\n   * Add render data\n   *\n   * @param {Object} stopInfo\n   */\n\n  addRenderData (pointInfo) {\n    if (pointInfo.offsetX !== 0 || pointInfo.offsetY !== 0) this.hasOffsetPoints = true\n    this.renderData.push(pointInfo)\n  }\n\n  clearRenderData () {\n    this.hasOffsetPoints = false\n    this.renderData = []\n  }\n\n  /**\n   * Draw a multipoint\n   *\n   * @param {Display} display\n   */\n\n  render (display) {\n    super.render(display)\n\n    if (!this.renderData) return\n\n    // Compute the bounds of the merged marker\n    const xArr = this.renderData.map(d => d.x)\n    const yArr = this.renderData.map(d => d.y)\n    const xMin = Math.min(...xArr)\n    const xMax = Math.max(...xArr)\n    const yMin = Math.min(...yArr)\n    const yMax = Math.max(...yArr)\n\n    const r = 6\n    const x = xMin - r\n    const y = yMin - r\n    const width = xMax - xMin + r * 2\n    const height = yMax - yMin + r * 2\n\n    // Draw the merged marker\n    display.drawRect({ x, y }, {\n      width,\n      height,\n      rx: r,\n      ry: r,\n      fill: '#fff',\n      stroke: '#000',\n      'stroke-width': 2\n    })\n\n    // Store marker bounding box\n    this.markerBBox = { x, y, width, height }\n\n    // TODO: support pattern-specific markers\n  }\n\n  initMergedMarker (display) {\n    // set up the merged marker\n    if (this.fromPoint || this.toPoint) {\n      this.mergedMarker = this.markerSvg.append('g').append('circle')\n        .datum({\n          owner: this\n        })\n        .attr('class', 'transitive-multipoint-marker-merged')\n    } else if (this.hasOffsetPoints || this.renderData.length > 1) {\n      this.mergedMarker = this.markerSvg.append('g').append('rect')\n        .datum({\n          owner: this\n        })\n        .attr('class', 'transitive-multipoint-marker-merged')\n    }\n  }\n\n  getRenderDataArray () {\n    return this.renderData\n  }\n\n  setFocused (focused) {\n    this.focused = focused\n    forEach(this.points, point => {\n      point.setFocused(focused)\n    })\n  }\n\n  runFocusTransition (display, callback) {\n    if (this.mergedMarker) {\n      var newStrokeColor = display.styler.compute(display.styler.multipoints_merged\n        .stroke, display, {\n          owner: this\n        })\n      this.mergedMarker.transition().style('stroke', newStrokeColor).call(\n        callback)\n    }\n    if (this.label) this.label.runFocusTransition(display, callback)\n  }\n}\n"]}