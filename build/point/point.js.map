{"version":3,"sources":["point.js"],"names":["Point","data","key","paths","renderData","label","renderLabel","focused","sortableType","placeOffsets","x","y","zIndex","getType","toLowerCase","getId","display","dataArray","getRenderDataArray","xValues","yValues","forEach","push","minX","Math","min","apply","minY","maxX","max","maxY","markerType","styler","compute","stops_merged","owner","stylerRadius","r","width","height","dx","dy","markerPadding","patternRadius","patternStylerKey","parseFloat","rx","ry","mergedMarkerData","constructMergedMarker","adjacentPlace","placeR","places","placeX","xScale","worldX","placeY","yScale","worldY","thisR","thisX","thisY","dist","sqrt","f","graphVertex","incidentEdges","edge","renderSegments","segment","refreshRenderData","markerBBox","callback","xTotal","yTotal","length","transitive","getName"],"mappings":"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","file":"point.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport PointLabel from '../labeler/pointlabel'\n\nexport default class Point {\n  constructor (data) {\n    for (var key in data) {\n      this[key] = data[key]\n    }\n\n    this.paths = []\n    this.renderData = []\n\n    this.label = new PointLabel(this)\n    this.renderLabel = true\n\n    this.focused = true\n    this.sortableType = 'POINT'\n\n    this.placeOffsets = {\n      x: 0,\n      y: 0\n    }\n\n    this.zIndex = 10000\n  }\n\n  /**\n   * Get unique ID for point -- must be defined by subclass\n   */\n\n  getId () {}\n\n  getElementId () {\n    return this.getType().toLowerCase() + '-' + this.getId()\n  }\n\n  /**\n   * Get Point type -- must be defined by subclass\n   */\n\n  getType () {}\n\n  /**\n   * Get Point name\n   */\n\n  getName () {\n    return `${this.getType()} point (ID=${this.getId()})`\n  }\n\n  /**\n   * Get latitude\n   */\n\n  getLat () {\n    return 0\n  }\n\n  /**\n   * Get longitude\n   */\n\n  getLon () {\n    return 0\n  }\n\n  containsSegmentEndPoint () {\n    return false\n  }\n\n  containsBoardPoint () {\n    return false\n  }\n\n  containsAlightPoint () {\n    return false\n  }\n\n  containsTransferPoint () {\n    return false\n  }\n\n  getPatterns () {\n    return []\n  }\n\n  /**\n   * Draw the point\n   *\n   * @param {Display} display\n   */\n\n  render (display) {}\n\n  addRenderData () {}\n\n  clearRenderData () {}\n\n  containsFromPoint () {\n    return false\n  }\n\n  containsToPoint () {\n    return false\n  }\n\n  //* * Shared geom utility functions **//\n\n  constructMergedMarker (display) {\n    var dataArray = this.getRenderDataArray()\n    var xValues = []\n    var yValues = []\n    dataArray.forEach(function (data) {\n      var x = data.x\n      var y = data.y\n      xValues.push(x)\n      yValues.push(y)\n    })\n    var minX = Math.min.apply(Math, xValues)\n    var minY = Math.min.apply(Math, yValues)\n    var maxX = Math.max.apply(Math, xValues)\n    var maxY = Math.max.apply(Math, yValues)\n\n    // retrieve marker type and radius from the styler\n    var markerType = display.styler.compute(display.styler.stops_merged['marker-type'], display, {\n      owner: this\n    })\n    var stylerRadius = display.styler.compute(display.styler.stops_merged.r, display, {\n      owner: this\n    })\n\n    var width\n    var height\n    var r\n\n    // if this is a circle marker w/ a styler-defined fixed radius, use that\n    if (markerType === 'circle' && stylerRadius) {\n      width = height = stylerRadius * 2\n      r = stylerRadius\n    // otherwise, this is a dynamically-sized marker\n    } else {\n      var dx = maxX - minX\n      var dy = maxY - minY\n\n      var markerPadding = display.styler.compute(display.styler.stops_merged['marker-padding'], display, {\n        owner: this\n      }) || 0\n\n      var patternRadius = display.styler.compute(display.styler[this.patternStylerKey].r, display, {\n        owner: this\n      })\n      r = parseFloat(patternRadius) + markerPadding\n\n      if (markerType === 'circle') {\n        width = height = Math.max(dx, dy) + 2 * r\n        r = width / 2\n      } else {\n        width = dx + 2 * r\n        height = dy + 2 * r\n        if (markerType === 'rectangle') r = 0\n      }\n    }\n\n    return {\n      x: (minX + maxX) / 2 - width / 2,\n      y: (minY + maxY) / 2 - height / 2,\n      width: width,\n      height: height,\n      rx: r,\n      ry: r\n    }\n  }\n\n  initMarkerData (display) {\n    if (this.getType() !== 'STOP' && this.getType() !== 'MULTI') return\n\n    this.mergedMarkerData = this.constructMergedMarker(display)\n\n    this.placeOffsets = {\n      x: 0,\n      y: 0\n    }\n    if (this.adjacentPlace) {\n      var placeR = display.styler.compute(display.styler.places.r, display, {\n        owner: this.adjacentPlace\n      })\n\n      var placeX = display.xScale.compute(this.adjacentPlace.worldX)\n      var placeY = display.yScale.compute(this.adjacentPlace.worldY)\n\n      var thisR = this.mergedMarkerData.width / 2\n      var thisX = this.mergedMarkerData.x + thisR\n      var thisY = this.mergedMarkerData.y + thisR\n\n      var dx = thisX - placeX\n      var dy = thisY - placeY\n      var dist = Math.sqrt(dx * dx + dy * dy)\n\n      if (placeR + thisR > dist) {\n        var f = (placeR + thisR) / dist\n        this.placeOffsets = {\n          x: (dx * f) - dx,\n          y: (dy * f) - dy\n        }\n\n        this.mergedMarkerData.x += this.placeOffsets.x\n        this.mergedMarkerData.y += this.placeOffsets.y\n\n        forEach(this.graphVertex.incidentEdges(), edge => {\n          forEach(edge.renderSegments, segment => {\n            segment.refreshRenderData(display)\n          })\n        })\n      }\n    }\n  }\n\n  getMarkerBBox () {\n    return this.markerBBox\n  }\n\n  setFocused (focused) {\n    this.focused = focused\n  }\n\n  isFocused () {\n    return (this.focused === true)\n  }\n\n  runFocusTransition (display, callback) {}\n\n  setAllPatternsFocused () {}\n\n  getZIndex () {\n    return this.zIndex\n  }\n\n  getAverageCoord () {\n    var dataArray = this.getRenderDataArray()\n\n    var xTotal = 0\n    var yTotal = 0\n    forEach(dataArray, data => {\n      xTotal += data.x\n      yTotal += data.y\n    })\n\n    return {\n      x: xTotal / dataArray.length,\n      y: yTotal / dataArray.length\n    }\n  }\n\n  hasRenderData () {\n    var dataArray = this.getRenderDataArray()\n    return (dataArray && dataArray.length > 0)\n  }\n\n  makeDraggable (transitive) {}\n\n  toString () {\n    return `${this.getType()} point: ${this.getId()} (${this.getName()})`\n  }\n}\n"]}