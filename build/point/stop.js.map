{"version":3,"sources":["stop.js"],"names":["Stop","data","stop_lat","stop_lon","xy","forward","worldX","worldY","patterns","patternRenderData","patternFocused","patternCount","patternStylerKey","isSegmentEndPoint","stop_id","stop_name","getId","isBoardPoint","isAlightPoint","isTransferPoint","pattern","indexOf","push","stopInfo","rEdge","getType","s","sortableType","owner","getZIndex","graphVertex","key","patternId","patternIds","addPattern","length","focused","display","initMarkerData","styler","mergedMarkerData","drawRect","x","y","width","height","rx","ry","fill","compute2","stroke","markerBBox","renderDataArray","getRenderDataArray","dataArray","placeOffsets"],"mappings":"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","file":"stop.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport Point from './point'\nimport { sm } from '../util'\n\n/**\n *  Place: a Point subclass representing a 'place' that can be rendered on the\n *  map. A place is a point *other* than a transit stop/station, e.g. a home/work\n *  location, a point of interest, etc.\n */\n\nexport default class Stop extends Point {\n  constructor (data) {\n    super(data)\n\n    if (data && data.stop_lat && data.stop_lon) {\n      var xy = sm.forward([data.stop_lon, data.stop_lat])\n      this.worldX = xy[0]\n      this.worldY = xy[1]\n    }\n\n    this.patterns = []\n\n    this.patternRenderData = {}\n    this.patternFocused = {}\n    this.patternCount = 0\n\n    this.patternStylerKey = 'stops_pattern'\n\n    this.isSegmentEndPoint = false\n  }\n\n  /**\n   * Get id\n   */\n\n  getId () {\n    return this.stop_id\n  }\n\n  /**\n   * Get type\n   */\n\n  getType () {\n    return 'STOP'\n  }\n\n  /**\n   * Get name\n   */\n\n  getName () {\n    if (!this.stop_name) return `Unnamed Stop (ID=${this.getId()})`\n    return this.stop_name\n  }\n\n  /**\n   * Get lat\n   */\n\n  getLat () {\n    return this.stop_lat\n  }\n\n  /**\n   * Get lon\n   */\n\n  getLon () {\n    return this.stop_lon\n  }\n\n  containsSegmentEndPoint () {\n    return this.isSegmentEndPoint\n  }\n\n  containsBoardPoint () {\n    return this.isBoardPoint\n  }\n\n  containsAlightPoint () {\n    return this.isAlightPoint\n  }\n\n  containsTransferPoint () {\n    return this.isTransferPoint\n  }\n\n  getPatterns () {\n    return this.patterns\n  }\n\n  addPattern (pattern) {\n    if (this.patterns.indexOf(pattern) === -1) this.patterns.push(pattern)\n  }\n\n  /**\n   * Add render data\n   *\n   * @param {Object} stopInfo\n   */\n\n  addRenderData (stopInfo) {\n    if (stopInfo.rEdge.getType() === 'TRANSIT') {\n      var s = {\n        sortableType: 'POINT_STOP_PATTERN',\n        owner: this,\n        getZIndex: function () {\n          if (this.owner.graphVertex) {\n            return this.owner.getZIndex()\n          }\n          return this.rEdge.getZIndex() + 1\n        }\n      }\n\n      for (var key in stopInfo) s[key] = stopInfo[key]\n\n      var patternId = stopInfo.rEdge.patternIds\n      this.patternRenderData[patternId] = s // .push(s);\n\n      forEach(stopInfo.rEdge.patterns, pattern => {\n        this.addPattern(pattern)\n      })\n    }\n    this.patternCount = Object.keys(this.patternRenderData).length\n  }\n\n  isPatternFocused (patternId) {\n    if (!(patternId in this.patternFocused)) return true\n    return (this.patternFocused[patternId])\n  }\n\n  setPatternFocused (patternId, focused) {\n    this.patternFocused[patternId] = focused\n  }\n\n  setAllPatternsFocused (focused) {\n    for (var key in this.patternRenderData) {\n      this.patternFocused[key] = focused\n    }\n  }\n\n  /**\n   * Draw a stop\n   *\n   * @param {Display} display\n   */\n\n  render (display) {\n    super.render(display)\n\n    if (this.patternCount === 0) return\n\n    this.initMarkerData(display)\n\n    const styler = display.styler\n\n    // For segment endpoints, draw the \"merged\" marker\n    if (this.isSegmentEndPoint && this.mergedMarkerData) {\n      display.drawRect({\n        x: this.mergedMarkerData.x,\n        y: this.mergedMarkerData.y\n      }, {\n        width: this.mergedMarkerData.width,\n        height: this.mergedMarkerData.height,\n        rx: this.mergedMarkerData.rx,\n        ry: this.mergedMarkerData.ry,\n        fill: styler.compute2('stops_merged', 'fill', this),\n        stroke: styler.compute2('stops_merged', 'stroke', this),\n        'stroke-width': styler.compute2('stops_merged', 'stroke-width', this)\n      })\n\n      // store marker bounding box\n      this.markerBBox = {\n        x: this.mergedMarkerData.x,\n        y: this.mergedMarkerData.y,\n        width: this.mergedMarkerData.width,\n        height: this.mergedMarkerData.height\n      }\n    }\n\n    // TODO: Restore inline stop\n    if (!this.isSegmentEndPoint) {\n      const renderDataArray = this.getRenderDataArray()\n      /*for (let renderData of renderDataArray) {\n        display.drawCircle({\n          x: renderData.x,\n          y: renderData.y\n        }, {\n          fill: '#fff',\n          r: renderData.rEdge.lineWidth * 0.4\n        })\n      }*/\n    }\n  }\n\n  getRenderDataArray () {\n    var dataArray = []\n    for (var patternId in this.patternRenderData) {\n      dataArray.push(this.patternRenderData[patternId])\n    }\n    return dataArray\n  }\n\n  clearRenderData () {\n    this.patternRenderData = {}\n    this.mergedMarkerData = null\n    this.placeOffsets = {\n      x: 0,\n      y: 0\n    }\n  }\n}\n"]}