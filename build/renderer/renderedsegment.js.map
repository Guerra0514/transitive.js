{"version":3,"sources":["renderedsegment.js"],"names":["rSegmentId","RenderedSegment","pathSegment","id","renderedEdges","type","focused","rEdge","push","display","styler","renderData","concat","journeySegment","arc","first","last","length","v","x","y","vp","Math","PI","dist","radius","ex","ey","drawPath","fill","stroke","compute2","callback","newColor","compute","segments","lineGraph","transition","style","call","zIndex","includeEnvelope","env","envelope","parseFloat","substring","lw","other","mode","getId","textArray","patterns","shortName","pattern","route","route_short_name","indexOf","spacing","labelAnchors","computeRenderLength","anchorCount","floor","renderLength","pctSpacing","i","t","coord","coordAlongRenderedPath","loc","cur","edgeRenderLen","graphEdge","getRenderLength","t2","coordAlongEdge","toString"],"mappings":"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","file":"renderedsegment.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport { distance, normalizeVector, rotateVector } from '../util'\n\n/**\n * RenderedSegment\n */\n\nvar rSegmentId = 0\n\nexport default class RenderedSegment {\n  constructor (pathSegment) {\n    this.id = rSegmentId++\n    this.renderedEdges = []\n    this.pathSegment = pathSegment\n    if (pathSegment) this.type = pathSegment.type\n    this.focused = true\n  }\n\n  getId () {\n    return this.id\n  }\n\n  getType () {\n    return this.type\n  }\n\n  addRenderedEdge (rEdge) {\n    this.renderedEdges.push(rEdge)\n  }\n\n  render (display) {\n    const styler = display.styler\n\n    this.renderData = []\n    forEach(this.renderedEdges, rEdge => {\n      this.renderData = this.renderData.concat(rEdge.renderData)\n    })\n\n    // Check if this segment is to be drawn as an arc; if so replace render data\n    if (this.pathSegment.journeySegment && this.pathSegment.journeySegment.arc) {\n      const first = this.renderData[0]\n      const last = this.renderData[this.renderData.length - 1]\n      const v = {\n        x: last.x - first.x,\n        y: last.y - first.y\n      }\n      const vp = rotateVector(normalizeVector(v), -Math.PI / 2)\n      const dist = distance(first.x, first.y, last.x, last.y)\n      const arc = {\n        x: last.x,\n        y: last.y,\n        arc: -45,\n        radius: dist * 0.75,\n        ex: ((last.x + first.x) / 2) + vp.x * (dist / 4),\n        ey: ((last.y + first.y) / 2) + vp.y * (dist / 4)\n      }\n      this.renderData = [first, arc, last]\n    }\n\n    display.drawPath(this.renderData, {\n      fill: 'none',\n      stroke: styler.compute2('segments', 'stroke', this),\n      'stroke-width': styler.compute2('segments', 'stroke-width', this),\n      'stroke-dasharray': styler.compute2('segments', 'stroke-dasharray', this),\n      'stroke-linecap': styler.compute2('segments', 'stroke-linecap', this)\n    })\n  }\n\n  setFocused (focused) {\n    this.focused = focused\n  }\n\n  isFocused () {\n    return this.focused\n  }\n\n  runFocusTransition (display, callback) {\n    var newColor = display.styler.compute(display.styler.segments.stroke, display,\n      this)\n    this.lineGraph.transition().style('stroke', newColor).call(callback)\n  }\n\n  getZIndex () {\n    return this.zIndex\n  }\n\n  computeLineWidth (display, includeEnvelope) {\n    var styler = display.styler\n    if (styler && display) {\n      // compute the line width\n      var env = styler.compute(styler.segments.envelope, display, this)\n      if (env && includeEnvelope) {\n        return parseFloat(env.substring(0, env.length - 2), 10) - 2\n      } else {\n        var lw = styler.compute(styler.segments['stroke-width'], display, this)\n        return parseFloat(lw.substring(0, lw.length - 2), 10) - 2\n      }\n    }\n  }\n\n  compareTo (other) {\n    // show transit segments in front of other types\n    if (this.type === 'TRANSIT' && other.type !== 'TRANSIT') return -1\n    if (other.type === 'TRANSIT' && this.type !== 'TRANSIT') return 1\n\n    if (this.type === 'TRANSIT' && other.type === 'TRANSIT') {\n      // for two transit segments, try sorting transit mode first\n      if (this.mode && other.mode && this.mode !== other.mode) {\n        return (this.mode > other.mode)\n      }\n\n      // for two transit segments of the same mode, sort by id (for display consistency)\n      return (this.getId() < other.getId())\n    }\n  }\n\n  getLabelTextArray () {\n    var textArray = []\n    forEach(this.patterns, pattern => {\n      var shortName = pattern.route.route_short_name\n      if (textArray.indexOf(shortName) === -1) textArray.push(shortName)\n    })\n    return textArray\n  }\n\n  getLabelAnchors (display, spacing) {\n    var labelAnchors = []\n    this.computeRenderLength(display)\n    var anchorCount = Math.floor(this.renderLength / spacing)\n    var pctSpacing = spacing / this.renderLength\n\n    for (var i = 0; i < anchorCount; i++) {\n      var t = (i % 2 === 0)\n        ? 0.5 + (i / 2) * pctSpacing\n        : 0.5 - ((i + 1) / 2) * pctSpacing\n      var coord = this.coordAlongRenderedPath(t, display)\n      if (coord) labelAnchors.push(coord)\n    }\n\n    return labelAnchors\n  }\n\n  coordAlongRenderedPath (t, display) {\n    var loc = t * this.renderLength\n\n    var cur = 0\n    for (var i = 0; i < this.renderedEdges.length; i++) {\n      var rEdge = this.renderedEdges[i]\n      var edgeRenderLen = rEdge.graphEdge.getRenderLength(display)\n      if (loc <= cur + edgeRenderLen) {\n        var t2 = (loc - cur) / edgeRenderLen\n        return rEdge.graphEdge.coordAlongEdge(t2, rEdge.renderData, display)\n      }\n      cur += edgeRenderLen\n    }\n  }\n\n  computeRenderLength (display) {\n    this.renderLength = 0\n    forEach(this.renderedEdges, rEdge => {\n      this.renderLength += rEdge.graphEdge.getRenderLength(display)\n    })\n  }\n\n  toString () {\n    return `RenderedSegment ${this.id} on ${this.pathSegment ? this.pathSegment.toString() : ' (null segment)'}`\n  }\n}\n"]}