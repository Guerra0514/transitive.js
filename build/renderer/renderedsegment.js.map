{"version":3,"sources":["renderedsegment.js"],"names":["rSegmentId","RenderedSegment","pathSegment","id","renderedEdges","type","focused","rEdge","push","display","styler","renderData","concat","journeySegment","arc","first","last","length","x","y","radius","drawPath","fill","stroke","compute2","callback","newColor","compute","segments","lineGraph","transition","style","call","zIndex","includeEnvelope","env","envelope","parseFloat","substring","lw","other","mode","getId","textArray","patterns","shortName","pattern","route","route_short_name","indexOf","spacing","labelAnchors","computeRenderLength","anchorCount","Math","floor","renderLength","pctSpacing","i","t","coord","coordAlongRenderedPath","loc","cur","edgeRenderLen","graphEdge","getRenderLength","t2","coordAlongEdge","toString"],"mappings":"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","file":"renderedsegment.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport { distance, renderDataToSvgPath } from '../util'\n\n/**\n * RenderedSegment\n */\n\nvar rSegmentId = 0\n\nexport default class RenderedSegment {\n  constructor (pathSegment) {\n    this.id = rSegmentId++\n    this.renderedEdges = []\n    this.pathSegment = pathSegment\n    if (pathSegment) this.type = pathSegment.type\n    this.focused = true\n  }\n\n  getId () {\n    return this.id\n  }\n\n  getType () {\n    return this.type\n  }\n\n  addRenderedEdge (rEdge) {\n    this.renderedEdges.push(rEdge)\n  }\n\n  render (display) {\n    const styler = display.styler\n\n    this.renderData = []\n    forEach(this.renderedEdges, rEdge => {\n      this.renderData = this.renderData.concat(rEdge.renderData)\n    })\n\n    // Check if this segment is to be drawn as an arc; if so replace render data\n    if (this.pathSegment.journeySegment && this.pathSegment.journeySegment.arc) {\n      const first = this.renderData[0]\n      const last = this.renderData[this.renderData.length - 1]\n      const arc = {\n        x: last.x,\n        y: last.y,\n        arc: -45,\n        radius: distance(first.x, first.y, last.x, last.y)\n      }\n      this.renderData = [first, arc, last]\n    }\n\n    display.drawPath(renderDataToSvgPath(this.renderData), {\n      fill: 'none',\n      stroke: styler.compute2('segments', 'stroke', this),\n      'stroke-width': styler.compute2('segments', 'stroke-width', this),\n      'stroke-dasharray': styler.compute2('segments', 'stroke-dasharray', this),\n      'stroke-linecap': styler.compute2('segments', 'stroke-linecap', this)\n    })\n  }\n\n  setFocused (focused) {\n    this.focused = focused\n  }\n\n  isFocused () {\n    return this.focused\n  }\n\n  runFocusTransition (display, callback) {\n    var newColor = display.styler.compute(display.styler.segments.stroke, display,\n      this)\n    this.lineGraph.transition().style('stroke', newColor).call(callback)\n  }\n\n  getZIndex () {\n    return this.zIndex\n  }\n\n  computeLineWidth (display, includeEnvelope) {\n    var styler = display.styler\n    if (styler && display) {\n      // compute the line width\n      var env = styler.compute(styler.segments.envelope, display, this)\n      if (env && includeEnvelope) {\n        return parseFloat(env.substring(0, env.length - 2), 10) - 2\n      } else {\n        var lw = styler.compute(styler.segments['stroke-width'], display, this)\n        return parseFloat(lw.substring(0, lw.length - 2), 10) - 2\n      }\n    }\n  }\n\n  compareTo (other) {\n    // show transit segments in front of other types\n    if (this.type === 'TRANSIT' && other.type !== 'TRANSIT') return -1\n    if (other.type === 'TRANSIT' && this.type !== 'TRANSIT') return 1\n\n    if (this.type === 'TRANSIT' && other.type === 'TRANSIT') {\n      // for two transit segments, try sorting transit mode first\n      if (this.mode && other.mode && this.mode !== other.mode) {\n        return (this.mode > other.mode)\n      }\n\n      // for two transit segments of the same mode, sort by id (for display consistency)\n      return (this.getId() < other.getId())\n    }\n  }\n\n  getLabelTextArray () {\n    var textArray = []\n    forEach(this.patterns, pattern => {\n      var shortName = pattern.route.route_short_name\n      if (textArray.indexOf(shortName) === -1) textArray.push(shortName)\n    })\n    return textArray\n  }\n\n  getLabelAnchors (display, spacing) {\n    var labelAnchors = []\n    this.computeRenderLength(display)\n    var anchorCount = Math.floor(this.renderLength / spacing)\n    var pctSpacing = spacing / this.renderLength\n\n    for (var i = 0; i < anchorCount; i++) {\n      var t = (i % 2 === 0)\n        ? 0.5 + (i / 2) * pctSpacing\n        : 0.5 - ((i + 1) / 2) * pctSpacing\n      var coord = this.coordAlongRenderedPath(t, display)\n      if (coord) labelAnchors.push(coord)\n    }\n\n    return labelAnchors\n  }\n\n  coordAlongRenderedPath (t, display) {\n    var loc = t * this.renderLength\n\n    var cur = 0\n    for (var i = 0; i < this.renderedEdges.length; i++) {\n      var rEdge = this.renderedEdges[i]\n      var edgeRenderLen = rEdge.graphEdge.getRenderLength(display)\n      if (loc <= cur + edgeRenderLen) {\n        var t2 = (loc - cur) / edgeRenderLen\n        return rEdge.graphEdge.coordAlongEdge(t2, rEdge.renderData, display)\n      }\n      cur += edgeRenderLen\n    }\n  }\n\n  computeRenderLength (display) {\n    this.renderLength = 0\n    forEach(this.renderedEdges, rEdge => {\n      this.renderLength += rEdge.graphEdge.getRenderLength(display)\n    })\n  }\n\n  getLegendType () {\n    if (this.type === 'TRANSIT') {\n      return this.type + '_' + this.mode\n    }\n    return this.type\n  }\n\n  toString () {\n    return `RenderedSegment ${this.id} on ${this.pathSegment ? this.pathSegment.toString() : ' (null segment)'}`\n  }\n}\n"]}