{"version":3,"sources":["canvas-renderer.js"],"names":["CanvasRenderer","display","transitive","network","styler","legendSegments","renderedEdges","rEdge","refreshRenderData","paths","path","segments","pathSegment","renderedSegments","renderedSegment","render","legendType","getLegendType","graph","vertices","vertex","point","isDraggable","makeDraggable","edges","edge","pointArray","legend","refresh","panning","clearRenderData","refreshSegmentRenderData","initMarkerData","rSegment","push","svgGroup","stylePoint","styleStop","labeledElements","labeler","doLayout","points","refreshLabel","stylePointLabel","segmentLabels","label","styleSegmentLabel","sortElements","isectKeys","s","length","rEdge1","rEdge2","key","getId","indexOf","graphEdge","isInternal","intersect","sort","a","b","compareTo","focusBaseZIndex","index","zIndex","isFocused","svg","selectAll","aIndex","getZIndex","owner","bIndex","pathRenderedSegments","getRenderedSegments","forEach","i","setAllPatternsFocused","focusChangeSegments","focusedVertexPoints","setFocused","startVertex","endVertex","focusChangePoints"],"mappings":"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","file":"canvas-renderer.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport Renderer from './renderer'\n\n/**\n * A Renderer subclass for the default network rendering engine.\n *\n * @param {Object} the main Transitive object\n */\n\nexport default class CanvasRenderer extends Renderer {\n  render () {\n    super.render()\n\n    var display = this.transitive.display\n    var network = this.transitive.network\n    display.styler = this.transitive.styler\n\n    var legendSegments = {}\n\n    forEach(network.renderedEdges, rEdge => {\n      rEdge.refreshRenderData(display)\n    })\n\n    forEach(network.paths, path => {\n      forEach(path.segments, pathSegment => {\n        forEach(pathSegment.renderedSegments, renderedSegment => {\n          renderedSegment.render(display)\n          var legendType = renderedSegment.getLegendType()\n          if (!(legendType in legendSegments)) {\n            legendSegments[legendType] = renderedSegment\n          }\n        })\n      })\n    })\n\n    // draw the vertex-based points\n\n    forEach(network.graph.vertices, vertex => {\n      vertex.point.render(display)\n      if (this.isDraggable(vertex.point)) {\n        vertex.point.makeDraggable(this.transitive)\n      }\n    })\n\n    // draw the edge-based points\n    forEach(network.graph.edges, edge => {\n      forEach(edge.pointArray, point => {\n        point.render(display)\n      })\n    })\n\n    if (display.legend) display.legend.render(legendSegments)\n\n    this.transitive.refresh()\n  }\n\n  /**\n   * Refresh\n   */\n\n  refresh (panning) {\n    super.refresh(panning)\n\n    var display = this.transitive.display\n    var network = this.transitive.network\n    var styler = this.transitive.styler\n\n    forEach(network.graph.vertices, vertex => {\n      vertex.point.clearRenderData()\n    })\n    forEach(network.graph.edges, edge => {\n      edge.clearRenderData()\n    })\n\n    // refresh the segment and point marker data\n    this.refreshSegmentRenderData()\n    forEach(network.graph.vertices, vertex => {\n      vertex.point.initMarkerData(display)\n    })\n\n    this.renderedSegments = []\n    forEach(network.paths, path => {\n      forEach(path.segments, pathSegment => {\n        forEach(pathSegment.renderedSegments, rSegment => {\n          rSegment.refresh(display)\n          this.renderedSegments.push(rSegment)\n        })\n      })\n    })\n\n    forEach(network.graph.vertices, vertex => {\n      var point = vertex.point\n      if (!point.svgGroup) return // check if this point is not currently rendered\n      styler.stylePoint(display, point)\n      point.refresh(display)\n    })\n\n    // re-draw the edge-based points\n    forEach(network.graph.edges, edge => {\n      forEach(edge.pointArray, point => {\n        if (!point.svgGroup) return // check if this point is not currently rendered\n        styler.styleStop(display, point)\n        point.refresh(display)\n      })\n    })\n\n    // refresh the label layout\n    var labeledElements = this.transitive.labeler.doLayout()\n    forEach(labeledElements.points, point => {\n      point.refreshLabel(display)\n      styler.stylePointLabel(display, point)\n    })\n    forEach(this.transitive.labeler.segmentLabels, label => {\n      label.refresh(display)\n      styler.styleSegmentLabel(display, label)\n    })\n\n    this.sortElements()\n  }\n\n  refreshSegmentRenderData () {\n    forEach(this.transitive.network.renderedEdges, rEdge => {\n      rEdge.refreshRenderData(this.transitive.display)\n    })\n\n    // try intersecting adjacent rendered edges to create a smooth transition\n\n    var isectKeys = [] // keep track of edge-edge intersections we've already computed\n    forEach(this.transitive.network.paths, path => {\n      forEach(path.segments, pathSegment => {\n        forEach(pathSegment.renderedSegments, rSegment => {\n          for (var s = 0; s < rSegment.renderedEdges.length - 1; s++) {\n            var rEdge1 = rSegment.renderedEdges[s]\n            var rEdge2 = rSegment.renderedEdges[s + 1]\n            var key = rEdge1.getId() + '_' + rEdge2.getId()\n            if (isectKeys.indexOf(key) !== -1) continue\n            if (rEdge1.graphEdge.isInternal && rEdge2.graphEdge.isInternal) {\n              rEdge1.intersect(rEdge2)\n            }\n            isectKeys.push(key)\n          }\n        })\n      })\n    })\n  }\n\n  /**\n   * sortElements\n   */\n\n  sortElements () {\n    this.renderedSegments.sort(function (a, b) {\n      return (a.compareTo(b))\n    })\n\n    var focusBaseZIndex = 100000\n\n    forEach(this.renderedSegments, (rSegment, index) => {\n      rSegment.zIndex = index * 10 + (rSegment.isFocused()\n        ? focusBaseZIndex\n        : 0)\n    })\n\n    forEach(this.transitive.network.graph.vertices, vertex => {\n      var point = vertex.point\n      point.zIndex = point.zIndex + (point.isFocused() ? focusBaseZIndex : 0)\n    })\n\n    this.transitive.display.svg.selectAll('.transitive-sortable').sort(function (a, b) {\n      var aIndex = (typeof a.getZIndex === 'function') ? a.getZIndex() : a.owner\n        .getZIndex()\n      var bIndex = (typeof b.getZIndex === 'function') ? b.getZIndex() : b.owner\n        .getZIndex()\n      return aIndex - bIndex\n    })\n  }\n\n  /**\n   * focusPath\n   */\n\n  focusPath (path) {\n    var pathRenderedSegments = []\n    var graph = this.transitive.network.graph\n\n    if (path) { // if we're focusing a specific path\n      pathRenderedSegments = path.getRenderedSegments()\n\n      // un-focus all internal points\n      forEach(graph.edges, edge => {\n        edge.pointArray.forEach(function (point, i) {\n          point.setAllPatternsFocused(false)\n        })\n      })\n    } else { // if we're returing to 'all-focused' mode\n      // re-focus all internal points\n      forEach(graph.edges, edge => {\n        forEach(edge.pointArray, (point, i) => {\n          point.setAllPatternsFocused(true)\n        })\n      })\n    }\n\n    var focusChangeSegments = []\n    var focusedVertexPoints = []\n    forEach(this.renderedSegments, rSegment => {\n      if (path && pathRenderedSegments.indexOf(rSegment) === -1) {\n        if (rSegment.isFocused()) focusChangeSegments.push(rSegment)\n        rSegment.setFocused(false)\n      } else {\n        if (!rSegment.isFocused()) focusChangeSegments.push(rSegment)\n        rSegment.setFocused(true)\n        focusedVertexPoints.push(rSegment.pathSegment.startVertex().point)\n        focusedVertexPoints.push(rSegment.pathSegment.endVertex().point)\n      }\n    })\n\n    var focusChangePoints = []\n    forEach(graph.vertices, vertex => {\n      var point = vertex.point\n      if (focusedVertexPoints.indexOf(point) !== -1) {\n        if (!point.isFocused()) focusChangePoints.push(point)\n        point.setFocused(true)\n      } else {\n        if (point.isFocused()) focusChangePoints.push(point)\n        point.setFocused(false)\n      }\n    })\n\n    // bring the focused elements to the front for the transition\n    // if (path) this.sortElements();\n\n    // create a transition callback function that invokes refresh() after all transitions complete\n    /* var n = 0\n    var refreshOnEnd = (transition, callback) => {\n      transition\n        .each(() => { ++n })\n        .on('end', () => { if (!--n) this.transitive.refresh() })\n    }\n\n    // run the transtions on the affected elements\n    forEach(focusChangeSegments, segment => {\n      segment.runFocusTransition(this.transitive.display, refreshOnEnd)\n    })\n\n    forEach(focusChangePoints, point => {\n      point.runFocusTransition(this.transitive.display, refreshOnEnd)\n    }) */\n    this.transitive.refresh()\n  }\n}\n"]}