{"version":3,"sources":["default-renderer.js"],"names":["DefaultRenderer","display","transitive","network","styler","focusedPoints","unfocusedPoints","graph","vertices","vertex","point","clearRenderData","isFocused","push","renderedEdges","rEdge","refreshRenderData","focusedSegments","unfocusedSegments","paths","path","segments","pathSegment","renderedSegments","renderedSegment","forEach","rs","render","pt","labels","labeler","doLayout","pointLabels","label","segmentLabels","concat","isectKeys","s","rSegment","length","rEdge1","rEdge2","key","getId","indexOf","graphEdge","isInternal","intersect","sort","a","b","compareTo","focusBaseZIndex","index","zIndex","svg","selectAll","aIndex","getZIndex","owner","bIndex","pathRenderedSegments","getRenderedSegments","edges","edge","pointArray","i","setAllPatternsFocused","focusChangeSegments","focusedVertexPoints","setFocused","startVertex","endVertex","focusChangePoints"],"mappings":"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","file":"default-renderer.js","sourcesContent":["import { forEach } from 'lodash'\n\nimport Renderer from './renderer'\n\n/**\n * A Renderer subclass for the default network rendering engine.\n *\n * @param {Object} the main Transitive object\n */\n\nexport default class DefaultRenderer extends Renderer {\n  render () {\n    super.render()\n\n    var display = this.transitive.display\n    var network = this.transitive.network\n    display.styler = this.transitive.styler\n\n    // TODO: restore legend?\n    // var legendSegments = {}\n\n    // Process vertices/points\n    const focusedPoints = []\n    const unfocusedPoints = []\n    forEach(network.graph.vertices, vertex => {\n      vertex.point.clearRenderData()\n      if (!vertex.point.isFocused()) unfocusedPoints.push(vertex.point)\n      else focusedPoints.push(vertex.point)\n    })\n\n    forEach(network.renderedEdges, rEdge => {\n      rEdge.refreshRenderData(display)\n    })\n\n    // Create arrays of focused, unfocused RenderedSegments\n    const focusedSegments = []\n    const unfocusedSegments = []\n    forEach(network.paths, path => {\n      forEach(path.segments, pathSegment => {\n        forEach(pathSegment.renderedSegments, renderedSegment => {\n          if (renderedSegment.isFocused()) focusedSegments.push(renderedSegment)\n          else unfocusedSegments.push(renderedSegment)\n\n          /*\n          var legendType = renderedSegment.getLegendType()\n          if (!(legendType in legendSegments)) {\n            legendSegments[legendType] = renderedSegment\n          }\n          */\n        })\n      })\n    })\n\n    // Render elements in the following order:\n\n    // 1. Unfocused segments\n    unfocusedSegments.forEach(rs => rs.render(display))\n\n    // 2. Unfocused points\n    forEach(unfocusedPoints, pt => pt.render(display))\n\n    // 3. Focused segments\n    focusedSegments.forEach(rs => rs.render(display))\n\n    // 4. Focused points\n    forEach(focusedPoints, pt => pt.render(display))\n\n    // TODO: draw the edge-based points\n    /*forEach(network.graph.edges, edge => {\n      forEach(edge.pointArray, point => {\n        point.render(display)\n      })\n    })*/\n\n    // 5. Labels\n    const labels = this.transitive.labeler.doLayout()\n    forEach(labels.pointLabels, label => label.render(display))\n    forEach(labels.segmentLabels, label => label.render(display))\n\n    // Keep internal collection of rendered segments\n    this.renderedSegments = focusedSegments.concat(unfocusedSegments)\n\n    // TODO: make legends work again\n    // if (display.legend) display.legend.render(legendSegments)\n  }\n\n  refreshSegmentRenderData () {\n    forEach(this.transitive.network.renderedEdges, rEdge => {\n      rEdge.refreshRenderData(this.transitive.display)\n    })\n\n    // try intersecting adjacent rendered edges to create a smooth transition\n\n    var isectKeys = [] // keep track of edge-edge intersections we've already computed\n    forEach(this.transitive.network.paths, path => {\n      forEach(path.segments, pathSegment => {\n        forEach(pathSegment.renderedSegments, rSegment => {\n          for (var s = 0; s < rSegment.renderedEdges.length - 1; s++) {\n            var rEdge1 = rSegment.renderedEdges[s]\n            var rEdge2 = rSegment.renderedEdges[s + 1]\n            var key = rEdge1.getId() + '_' + rEdge2.getId()\n            if (isectKeys.indexOf(key) !== -1) continue\n            if (rEdge1.graphEdge.isInternal && rEdge2.graphEdge.isInternal) {\n              rEdge1.intersect(rEdge2)\n            }\n            isectKeys.push(key)\n          }\n        })\n      })\n    })\n  }\n\n  /**\n   * sortElements\n   */\n\n  sortElements () {\n    this.renderedSegments.sort(function (a, b) {\n      return (a.compareTo(b))\n    })\n\n    var focusBaseZIndex = 100000\n\n    forEach(this.renderedSegments, (rSegment, index) => {\n      rSegment.zIndex = index * 10 + (rSegment.isFocused()\n        ? focusBaseZIndex\n        : 0)\n    })\n\n    forEach(this.transitive.network.graph.vertices, vertex => {\n      var point = vertex.point\n      point.zIndex = point.zIndex + (point.isFocused() ? focusBaseZIndex : 0)\n    })\n\n    this.transitive.display.svg.selectAll('.transitive-sortable').sort(function (a, b) {\n      var aIndex = (typeof a.getZIndex === 'function') ? a.getZIndex() : a.owner\n        .getZIndex()\n      var bIndex = (typeof b.getZIndex === 'function') ? b.getZIndex() : b.owner\n        .getZIndex()\n      return aIndex - bIndex\n    })\n  }\n\n  /**\n   * focusPath\n   */\n\n  focusPath (path) {\n    var pathRenderedSegments = []\n    var graph = this.transitive.network.graph\n\n    if (path) { // if we're focusing a specific path\n      pathRenderedSegments = path.getRenderedSegments()\n\n      // un-focus all internal points\n      forEach(graph.edges, edge => {\n        edge.pointArray.forEach(function (point, i) {\n          point.setAllPatternsFocused(false)\n        })\n      })\n    } else { // if we're returing to 'all-focused' mode\n      // re-focus all internal points\n      forEach(graph.edges, edge => {\n        forEach(edge.pointArray, (point, i) => {\n          point.setAllPatternsFocused(true)\n        })\n      })\n    }\n\n    // Keep track of changed segments / points for transition animation (currently disabled)\n    var focusChangeSegments = []\n    var focusedVertexPoints = []\n\n    forEach(this.renderedSegments, rSegment => {\n      if (path && pathRenderedSegments.indexOf(rSegment) === -1) {\n        if (rSegment.isFocused()) focusChangeSegments.push(rSegment)\n        rSegment.setFocused(false)\n      } else {\n        if (!rSegment.isFocused()) focusChangeSegments.push(rSegment)\n        rSegment.setFocused(true)\n        focusedVertexPoints.push(rSegment.pathSegment.startVertex().point)\n        focusedVertexPoints.push(rSegment.pathSegment.endVertex().point)\n      }\n    })\n\n    var focusChangePoints = []\n    forEach(graph.vertices, vertex => {\n      var point = vertex.point\n      if (focusedVertexPoints.indexOf(point) !== -1) {\n        if (!point.isFocused()) focusChangePoints.push(point)\n        point.setFocused(true)\n      } else {\n        if (point.isFocused()) focusChangePoints.push(point)\n        point.setFocused(false)\n      }\n    })\n\n    // bring the focused elements to the front for the transition\n    // if (path) this.sortElements();\n\n    // TODO: restore transitions\n    /*\n    // create a transition callback function that invokes refresh() after all transitions complete\n    var n = 0\n    var refreshOnEnd = (transition, callback) => {\n      transition\n        .each(() => { ++n })\n        .on('end', () => { if (!--n) this.transitive.refresh() })\n    }\n\n    // run the transtions on the affected elements\n    forEach(focusChangeSegments, segment => {\n      segment.runFocusTransition(this.transitive.display, refreshOnEnd)\n    })\n\n    forEach(focusChangePoints, point => {\n      point.runFocusTransition(this.transitive.display, refreshOnEnd)\n    })\n    */\n    this.transitive.render()\n  }\n}\n"]}